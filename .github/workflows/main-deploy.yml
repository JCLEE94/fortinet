name: Unified GitOps Pipeline

on:
  push:
    branches: [master, main, develop]
  pull_request:
    branches: [master, main]
  workflow_dispatch:
    inputs:
      action:
        description: 'Deployment Action'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - rollback
          - status
      environment:
        description: 'Target Environment'
        required: true
        default: 'production'
        type: choice
        options:
          - development
          - staging
          - production
      skip_tests:
        description: 'Skip Tests'
        required: false
        default: false
        type: boolean

env:
  # Registry Configuration
  REGISTRY_URL: ${{ secrets.REGISTRY_URL || 'registry.jclee.me' }}
  CHARTMUSEUM_URL: ${{ secrets.CHARTMUSEUM_URL || 'https://charts.jclee.me' }}
  ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER || 'https://argo.jclee.me' }}
  
  # Project Configuration
  PROJECT_NAME: fortinet
  K8S_NAMESPACE: fortinet
  PYTHON_VERSION: '3.11'
  
  # URLs
  DEPLOYMENT_HOST: ${{ secrets.DEPLOYMENT_HOST || '192.168.50.110' }}
  DEPLOYMENT_PORT: ${{ secrets.DEPLOYMENT_PORT || '30777' }}

jobs:
  # ===========================
  # CONFIGURATION
  # ===========================
  config:
    name: 📋 Configuration
    runs-on: ubuntu-latest
    outputs:
      should_test: ${{ steps.config.outputs.should_test }}
      should_deploy: ${{ steps.config.outputs.should_deploy }}
      environment: ${{ steps.config.outputs.environment }}
      action: ${{ steps.config.outputs.action }}
    steps:
      - id: config
        run: |
          # Determine action and environment
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ACTION="${{ github.event.inputs.action }}"
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            SHOULD_TEST="${{ github.event.inputs.skip_tests != 'true' }}"
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            ACTION="test"
            ENVIRONMENT="development"
            SHOULD_TEST="true"
          else
            ACTION="deploy"
            ENVIRONMENT="production"
            SHOULD_TEST="true"
          fi
          
          # Deployment logic
          if [[ "$ACTION" == "deploy" && ("${{ github.ref }}" == "refs/heads/master" || "${{ github.ref }}" == "refs/heads/main") ]]; then
            SHOULD_DEPLOY="true"
          else
            SHOULD_DEPLOY="false"
          fi
          
          echo "action=$ACTION" >> $GITHUB_OUTPUT
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "should_test=$SHOULD_TEST" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT

  # ===========================
  # PARALLEL TESTING
  # ===========================
  test:
    name: 🧪 Tests (${{ matrix.test-type }})
    needs: config
    if: needs.config.outputs.should_test == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        test-type: [unit, integration, security, quality]
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          
          case "${{ matrix.test-type }}" in
            unit|integration)
              pip install pytest pytest-cov pytest-xdist
              ;;
            security)
              pip install safety bandit
              ;;
            quality)
              pip install black isort flake8
              ;;
          esac
      
      - name: Run ${{ matrix.test-type }} tests
        run: |
          case "${{ matrix.test-type }}" in
            unit)
              cd src && python -m pytest ../tests/unit/ -v --cov=. --cov-report=xml -n auto || true
              ;;
            integration)
              cd src && python -m pytest ../tests/integration/ ../tests/functional/ -v --cov=. --cov-report=xml -n auto || true
              ;;
            security)
              safety scan --policy-file=.safety-policy.yml || safety scan || true
              bandit -r src/ -f json -o bandit-report.json || true
              ;;
            quality)
              black --check src/
              isort --check-only src/
              flake8 src/ --max-line-length=120 --ignore=E203,W503
              ;;
          esac
      
      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-${{ matrix.test-type }}-${{ github.run_id }}
          path: |
            src/coverage.xml
            bandit-report.json
          retention-days: 7

  # ===========================
  # BUILD & PUSH
  # ===========================
  build:
    name: 🏗️ Build & Push
    needs: [config, test]
    if: needs.config.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      chart_version: ${{ steps.meta.outputs.chart_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Registry
        uses: docker/login-action@v3
        with:
          registry: registry.jclee.me
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}
      
      - name: Generate metadata
        id: meta
        run: |
          # Generate immutable tag and versions
          BRANCH=${GITHUB_REF#refs/heads/}
          SHORT_SHA=${GITHUB_SHA::7}
          IMAGE_TAG="${BRANCH}-${SHORT_SHA}"
          CHART_VERSION="1.0.${{ github.run_number }}"
          BUILD_TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
          
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "chart_version=${CHART_VERSION}" >> $GITHUB_OUTPUT
          echo "build_timestamp=${BUILD_TIMESTAMP}" >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64
          tags: |
            registry.jclee.me/fortinet:${{ steps.meta.outputs.image_tag }}
            registry.jclee.me/fortinet:latest
          build-args: |
            BUILD_DATE=${{ steps.meta.outputs.build_timestamp }}
            BUILD_TIMESTAMP=${{ steps.meta.outputs.build_timestamp }}
            GIT_COMMIT=${{ github.sha }}
            GIT_SHA=${{ steps.meta.outputs.short_sha }}
            GIT_BRANCH=${{ steps.meta.outputs.branch }}
            VERSION=${{ github.run_number }}
            IMMUTABLE_TAG=${{ steps.meta.outputs.image_tag }}
            REGISTRY_URL=${{ env.REGISTRY_URL }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ===========================
  # HELM CHART
  # ===========================
  helm:
    name: 📦 Helm Chart
    needs: [config, build]
    if: needs.config.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.0'
      
      - name: Package and upload chart
        run: |
          # Update chart versions
          sed -i "s/^version:.*/version: ${{ needs.build.outputs.chart_version }}/" charts/fortinet/Chart.yaml
          sed -i "s/^appVersion:.*/appVersion: \"${{ needs.build.outputs.image_tag }}\"/" charts/fortinet/Chart.yaml
          
          # Package chart
          helm package charts/fortinet --destination ./
          
          # Upload to ChartMuseum
          CHART_FILE="fortinet-${{ needs.build.outputs.chart_version }}.tgz"
          curl -L --data-binary "@${CHART_FILE}" \
            -u "${{ secrets.CHARTMUSEUM_USERNAME }}:${{ secrets.CHARTMUSEUM_PASSWORD }}" \
            "${{ env.CHARTMUSEUM_URL }}/api/charts"

  # ===========================
  # DEPLOY VIA ARGOCD
  # ===========================
  deploy:
    name: 🚀 Deploy
    needs: [config, build, helm]
    if: needs.config.outputs.action == 'deploy' && needs.config.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.config.outputs.environment }}
    steps:
      - name: Install ArgoCD CLI
        run: |
          VERSION=$(curl -s https://api.github.com/repos/argoproj/argo-cd/releases/latest | grep -Po '"tag_name": "\K.*?(?=")')
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/download/$VERSION/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd
      
      - name: Deploy via ArgoCD
        run: |
          # Login to ArgoCD
          argocd login ${ARGOCD_SERVER#https://} \
            --username admin \
            --password ${{ secrets.ARGOCD_PASSWORD }} \
            --insecure \
            --grpc-web
          
          # Update app with new image
          argocd app set ${{ env.PROJECT_NAME }} \
            --helm-set image.tag=${{ needs.build.outputs.image_tag }} \
            --grpc-web
          
          # Sync application
          argocd app sync ${{ env.PROJECT_NAME }} \
            --force \
            --prune \
            --retry-limit 3 \
            --grpc-web
          
          # Wait for deployment
          argocd app wait ${{ env.PROJECT_NAME }} \
            --sync \
            --health \
            --timeout 600 \
            --grpc-web

  # ===========================
  # VERIFY DEPLOYMENT
  # ===========================
  verify:
    name: ✅ Verify
    needs: [config, build, deploy]
    if: always() && needs.deploy.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Health check
        run: |
          MAX_RETRIES=10
          RETRY_DELAY=30
          HEALTH_URL="http://${{ env.DEPLOYMENT_HOST }}:${{ env.DEPLOYMENT_PORT }}/api/health"
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i/$MAX_RETRIES..."
            
            if curl -s --max-time 10 "${HEALTH_URL}" | jq -e '.status == "healthy"'; then
              echo "✅ Deployment verified successfully!"
              
              # Verify immutable tag
              DEPLOYED_TAG=$(curl -s "${HEALTH_URL}" | jq -r '.build_info.immutable_tag // "unknown"')
              EXPECTED_TAG="${{ needs.build.outputs.image_tag }}"
              
              if [ "${DEPLOYED_TAG}" = "${EXPECTED_TAG}" ]; then
                echo "✅ Immutable tag verified: ${DEPLOYED_TAG}"
                exit 0
              else
                echo "⚠️ Tag mismatch - Expected: ${EXPECTED_TAG}, Got: ${DEPLOYED_TAG}"
              fi
            fi
            
            [ $i -lt $MAX_RETRIES ] && sleep $RETRY_DELAY
          done
          
          echo "❌ Deployment verification failed"
          exit 1

  # ===========================
  # ROLLBACK
  # ===========================
  rollback:
    name: ⏪ Rollback
    needs: config
    if: needs.config.outputs.action == 'rollback'
    runs-on: ubuntu-latest
    environment: ${{ needs.config.outputs.environment }}
    steps:
      - name: Install ArgoCD CLI
        run: |
          VERSION=$(curl -s https://api.github.com/repos/argoproj/argo-cd/releases/latest | grep -Po '"tag_name": "\K.*?(?=")')
          curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/download/$VERSION/argocd-linux-amd64
          chmod +x /usr/local/bin/argocd
      
      - name: Perform rollback
        run: |
          # Login to ArgoCD
          argocd login ${ARGOCD_SERVER#https://} \
            --username admin \
            --password ${{ secrets.ARGOCD_PASSWORD }} \
            --insecure \
            --grpc-web
          
          # Get previous revision
          PREVIOUS=$(argocd app history ${{ env.PROJECT_NAME }} --output json --grpc-web | jq -r '.[1].revision')
          
          # Rollback
          argocd app rollback ${{ env.PROJECT_NAME }} $PREVIOUS --grpc-web
          
          # Wait for rollback
          argocd app wait ${{ env.PROJECT_NAME }} \
            --sync \
            --health \
            --timeout 300 \
            --grpc-web

  # ===========================
  # STATUS REPORT
  # ===========================
  status:
    name: 📊 Status
    needs: [config, deploy, rollback, verify]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate status report
        run: |
          cat << EOF > status.md
          # Deployment Status Report
          
          **Project:** ${{ env.PROJECT_NAME }}
          **Environment:** ${{ needs.config.outputs.environment }}
          **Action:** ${{ needs.config.outputs.action }}
          **Timestamp:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          
          ## Results
          - Config: ${{ needs.config.result }}
          - Tests: ${{ needs.test.result }}
          - Build: ${{ needs.build.result }}
          - Deploy: ${{ needs.deploy.result }}
          - Verify: ${{ needs.verify.result }}
          - Rollback: ${{ needs.rollback.result }}
          
          ## Access Points
          - Health: http://${{ env.DEPLOYMENT_HOST }}:${{ env.DEPLOYMENT_PORT }}/api/health
          - Application: http://${{ env.DEPLOYMENT_HOST }}:${{ env.DEPLOYMENT_PORT }}/
          - ArgoCD: ${{ env.ARGOCD_SERVER }}
          EOF
          
          cat status.md
      
      - name: Upload status report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-status-${{ github.run_id }}
          path: status.md
          retention-days: 30