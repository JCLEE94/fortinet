name: Main CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop ]
    tags: [ 'v*' ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [ main, master ]

# ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# GitHub Token ê¶Œí•œ ì„¤ì •
permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read

env:
  REGISTRY: ${{ vars.DOCKER_REGISTRY || 'registry.jclee.me' }}
  IMAGE_NAME: ${{ vars.DOCKER_IMAGE_NAME || 'fortinet' }}
  PYTHON_VERSION: '3.11'
  DEPLOY_METHOD: ${{ vars.DEPLOY_METHOD || 'argocd' }}  # argocd, k8s-direct
  ARGOCD_SERVER: 'argo.jclee.me'
  ARGOCD_APP_NAME: 'fortinet'

jobs:
  # í…ŒìŠ¤íŠ¸ ë° í’ˆì§ˆ ê²€ì‚¬
  test:
    name: ðŸ§ª Test & Quality
    runs-on: ubuntu-latest
    
    steps:
    - name: ðŸ“¥ Checkout
      uses: actions/checkout@v4
      
    - name: ðŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: ðŸ“¦ Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov black flake8 mypy
        
    - name: ðŸ” Code Quality
      run: |
        echo "Running code quality checks..."
        black --check src/ || true
        flake8 src/ --max-line-length=120 --ignore=E203,W503 || true
        mypy src/ --ignore-missing-imports || true
        
    - name: ðŸ§ª Run Tests
      run: |
        cd src
        python -m pytest ../tests/ -v || echo "Some tests failed"

  # Docker ë¹Œë“œ
  build:
    name: ðŸ—ï¸ Build & Push
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      short-sha: ${{ steps.vars.outputs.short-sha }}
      
    steps:
    - name: ðŸ“¥ Checkout
      uses: actions/checkout@v4
      
    - name: ðŸ”§ Set Variables
      id: vars
      run: |
        echo "short-sha=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
        echo "timestamp=$(date -u +%Y%m%d%H%M%S)" >> $GITHUB_OUTPUT
      
    - name: ðŸ·ï¸ Docker Meta
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: ðŸ” Registry Login
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}
        
    - name: ðŸ—ï¸ Build and Push
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.production
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          VCS_REF=${{ github.sha }}
          VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}

  # ë°°í¬
  deploy:
    name: ðŸš€ Deploy
    needs: build
    runs-on: ubuntu-latest  # ìž„ì‹œë¡œ ubuntu-latest ì‚¬ìš©
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - name: ðŸ“¥ Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
      
    - name: ðŸ”§ Setup Environment
      run: |
        echo "ðŸ“‹ Deployment Configuration:"
        echo "Method: ${{ env.DEPLOY_METHOD }}"
        echo "Image: ${{ needs.build.outputs.image-tag }}"
        echo "Registry: ${{ env.REGISTRY }}"
        echo "Short SHA: ${{ needs.build.outputs.short-sha }}"
        
    # Git ì„¤ì •
    - name: ðŸ”§ Configure Git
      run: |
        git config user.name "GitHub Actions Bot"
        git config user.email "actions@github.com"
    
    # ArgoCD CLI ì„¤ì¹˜ (self-hosted runner)
    - name: ðŸ“¦ Install/Update ArgoCD CLI
      run: |
        echo "ðŸ“¦ Checking ArgoCD CLI..."
        
        # Check if argocd is already installed
        if command -v argocd &> /dev/null; then
          echo "âœ… ArgoCD CLI already installed"
          argocd version --client
        else
          echo "ðŸ“¦ Installing ArgoCD CLI..."
          VERSION=$(curl -s https://api.github.com/repos/argoproj/argo-cd/releases/latest | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
          echo "Installing ArgoCD CLI version: $VERSION"
          curl -sSL -o argocd "https://github.com/argoproj/argo-cd/releases/download/$VERSION/argocd-linux-amd64"
          chmod +x argocd
          sudo mv argocd /usr/local/bin/argocd || mv argocd /usr/local/bin/argocd
          argocd version --client
        fi

    # ArgoCD ë°°í¬ (ê°œì„ ëœ ë²„ì „)
    - name: ðŸŽ¯ Deploy via ArgoCD
      env:
        ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
        ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
      run: |
        echo "ðŸŽ¯ Deploying via ArgoCD..."
        
        # Extract short SHA
        SHORT_SHA="${{ needs.build.outputs.short-sha }}"
        echo "Using image tag: $SHORT_SHA"
        
        # Update kustomization.yaml with new image tag
        sed -i "s|newTag:.*|newTag: $SHORT_SHA|g" k8s/manifests/kustomization.yaml
        
        # Add deployment metadata
        if ! grep -q "commonAnnotations:" k8s/manifests/kustomization.yaml; then
          cat >> k8s/manifests/kustomization.yaml << EOF

commonAnnotations:
  app.kubernetes.io/version: "$SHORT_SHA"
  deployed-by: "github-actions"
  deployed-at: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
EOF
        else
          sed -i "s|app.kubernetes.io/version:.*|app.kubernetes.io/version: \"$SHORT_SHA\"|g" k8s/manifests/kustomization.yaml
          sed -i "s|deployed-at:.*|deployed-at: \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"|g" k8s/manifests/kustomization.yaml
        fi
        
        # Show the changes
        echo "ðŸ“ Changes to be committed:"
        git diff k8s/manifests/kustomization.yaml
        
        # Commit and push changes
        git add k8s/manifests/kustomization.yaml
        
        if ! git diff --cached --quiet; then
          git commit -m "ðŸš€ Update image tag to $SHORT_SHA

ðŸ“‹ Deployment Info:
- Triggered by: ${{ github.event_name }}
- Branch: ${{ github.ref_name }}
- Actor: ${{ github.actor }}
- Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$SHORT_SHA
- Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')

ðŸ¤– Auto-generated by GitHub Actions"
          
          # Push with retry logic
          for i in {1..3}; do
            if git push origin HEAD:${{ github.ref_name }}; then
              echo "âœ… Git changes pushed successfully"
              break
            else
              echo "âš ï¸ Push attempt $i failed, retrying..."
              git pull --rebase origin ${{ github.ref_name }}
            fi
          done
        else
          echo "â„¹ï¸ No changes to commit"
        fi
        
        # Wait for git to propagate
        echo "â³ Waiting for git propagation..."
        sleep 10
        
        # ArgoCD Login using CLI
        echo "ðŸ” Logging into ArgoCD..."
        
        # Try multiple authentication methods
        AUTH_SUCCESS=false
        
        # Method 1: Try with password from secrets
        if [[ -n "${{ secrets.ARGOCD_PASSWORD }}" ]]; then
          echo "Trying password authentication..."
          if argocd login ${{ env.ARGOCD_SERVER }} \
            --username admin \
            --password ${{ secrets.ARGOCD_PASSWORD }} \
            --insecure \
            --grpc-web 2>&1; then
            AUTH_SUCCESS=true
            echo "âœ… Password authentication successful"
          else
            echo "âš ï¸ Password authentication failed"
          fi
        fi
        
        # Method 2: Try with auth token
        if [[ "$AUTH_SUCCESS" == "false" && -n "${{ secrets.ARGOCD_AUTH_TOKEN }}" ]]; then
          echo "Trying token authentication..."
          export ARGOCD_AUTH_TOKEN="${{ secrets.ARGOCD_AUTH_TOKEN }}"
          if argocd app list --grpc-web --server ${{ env.ARGOCD_SERVER }} 2>&1; then
            AUTH_SUCCESS=true
            echo "âœ… Token authentication successful"
          else
            echo "âš ï¸ Token authentication failed"
          fi
        fi
        
        # Method 3: Check if already logged in (self-hosted runner might have persistent auth)
        if [[ "$AUTH_SUCCESS" == "false" ]]; then
          echo "Checking existing authentication..."
          if argocd app list --grpc-web 2>&1; then
            AUTH_SUCCESS=true
            echo "âœ… Using existing authentication"
          else
            echo "âŒ No valid authentication available"
          fi
        fi
        
        # Only proceed with ArgoCD operations if authenticated
        if [[ "$AUTH_SUCCESS" == "true" ]]; then
          # Get current sync status
          echo "ðŸ“Š Current application status:"
          argocd app get ${{ env.ARGOCD_APP_NAME }} || echo "Failed to get app status"
          
          # Trigger manual sync
          echo "ðŸ”„ Triggering ArgoCD sync..."
          argocd app sync ${{ env.ARGOCD_APP_NAME }} \
            --prune \
            --force \
            --retry-limit 3 \
            --retry-backoff-duration 10s || echo "âš ï¸ Sync command failed, but ArgoCD auto-sync should pick up changes"
        else
          echo "âš ï¸ Skipping ArgoCD sync due to authentication failure"
          echo "ðŸ“Œ ArgoCD will auto-sync from Git changes (polling interval: 3 minutes)"
          echo ""
          echo "ðŸ”§ To fix authentication:"
          echo "1. Run: ./scripts/setup-argocd-auth.sh"
          echo "2. Add generated token to GitHub Secrets"
          echo "3. Or run: ./scripts/setup-self-hosted-runner.sh on the runner machine"
        fi
        
        # Wait and check sync status only if authenticated
        if [[ "$AUTH_SUCCESS" == "true" ]]; then
          echo "â³ Waiting for sync to complete..."
          for i in {1..10}; do
            sleep 10
            SYNC_STATUS=$(argocd app get ${{ env.ARGOCD_APP_NAME }} -o json | jq -r '.status.sync.status' || echo "Unknown")
            HEALTH_STATUS=$(argocd app get ${{ env.ARGOCD_APP_NAME }} -o json | jq -r '.status.health.status' || echo "Unknown")
            
            echo "Attempt $i/10 - Sync: $SYNC_STATUS, Health: $HEALTH_STATUS"
            
            if [[ "$SYNC_STATUS" == "Synced" ]]; then
              echo "âœ… Application synced successfully!"
              break
            fi
          done
          
          # Final status
          echo "ðŸ“Š Final application status:"
          argocd app get ${{ env.ARGOCD_APP_NAME }} || echo "Failed to get final status"
        else
          echo "ðŸ“Œ Summary:"
          echo "- Git changes have been pushed successfully"
          echo "- ArgoCD will detect and sync changes automatically"
          echo "- Check ArgoCD dashboard: https://argo.jclee.me/applications/${{ env.ARGOCD_APP_NAME }}"
        fi

    # í—¬ìŠ¤ ì²´í¬
    - name: ðŸ¥ Health Check
      if: always()
      run: |
        echo "ðŸ¥ Running health check..."
        
        # Wait for deployment to stabilize
        echo "â³ Waiting 60s for deployment to stabilize..."
        sleep 60
        
        # Check application health
        MAX_ATTEMPTS=5
        for i in $(seq 1 $MAX_ATTEMPTS); do
          echo "ðŸ” Health check attempt $i/$MAX_ATTEMPTS..."
          
          # Try to reach the application
          if curl -f -k -s -m 10 https://fortinet.jclee.me/api/health; then
            echo "âœ… Application is healthy!"
            exit 0
          else
            echo "âŒ Health check failed"
          fi
          
          # Don't wait after last attempt
          if [ $i -lt $MAX_ATTEMPTS ]; then
            echo "â³ Waiting 30s before next attempt..."
            sleep 30
          fi
        done
        
        echo "âŒ Health check failed after $MAX_ATTEMPTS attempts"
        exit 1

  # ì˜¤í”„ë¼ì¸ íŒ¨í‚¤ì§€ ìƒì„±
  offline-package:
    name: ðŸ“¦ Create Offline Package
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || startsWith(github.ref, 'refs/tags/'))
    
    outputs:
      package_name: ${{ steps.create-package.outputs.package_name }}
      package_sha256: ${{ steps.create-package.outputs.package_sha256 }}
    
    steps:
    - name: ðŸ“¥ Checkout
      uses: actions/checkout@v4
      
    - name: ðŸ” Registry Login
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}
        
    - name: ðŸ³ Pull Built Image
      run: |
        # Extract the first tag from build output
        IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tag }}" | cut -d',' -f1 | xargs)
        echo "Pulling image: $IMAGE_TAG"
        docker pull $IMAGE_TAG
        docker tag $IMAGE_TAG fortigate-nextrade:latest
        
    - name: ðŸ“¦ Create Offline Package
      id: create-package
      run: |
        echo "ðŸ”§ Creating offline deployment package..."
        
        # Set variables
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        VERSION="${{ github.ref_name }}-${GITHUB_SHA:0:7}"
        PACKAGE_NAME="fortinet-offline-deploy-${VERSION}-${TIMESTAMP}"
        TEMP_DIR="./${PACKAGE_NAME}"
        
        # Create temp directory
        mkdir -p "${TEMP_DIR}"
        
        # Create directories structure
        mkdir -p "${TEMP_DIR}/images"
        mkdir -p "${TEMP_DIR}/manifests"
        mkdir -p "${TEMP_DIR}/scripts"
        mkdir -p "${TEMP_DIR}/config"
        
        # 1. Save Docker image
        echo "ðŸ’¾ Saving Docker image..."
        docker save -o "${TEMP_DIR}/images/fortigate-nextrade.tar" fortigate-nextrade:latest
        
        # 2. Copy Kubernetes manifests
        echo "ðŸ“‹ Copying Kubernetes manifests..."
        cp -r k8s/manifests/* "${TEMP_DIR}/manifests/"
        
        # 3. Copy deployment scripts
        echo "ðŸ“ Copying deployment scripts..."
        if [ -f "deploy/installers/fortinet-installer.sh" ]; then
          cp deploy/installers/fortinet-installer.sh "${TEMP_DIR}/scripts/"
        fi
        if [ -f "deploy/installers/fortinet-installer.ps1" ]; then
          cp deploy/installers/fortinet-installer.ps1 "${TEMP_DIR}/scripts/"
        fi
        
        # 4. Copy configuration files
        echo "âš™ï¸ Copying configuration files..."
        if [ -d "data" ]; then
          cp -r data/*.json "${TEMP_DIR}/config/" 2>/dev/null || echo "No JSON config files found"
        fi
        
        # Create a default config.json if not exists
        if [ ! -f "${TEMP_DIR}/config/config.json" ]; then
          echo '{"app_mode": "production", "offline_mode": true}' > "${TEMP_DIR}/config/config.json"
        fi
        
        # 5. Create deployment instructions
        cat > "${TEMP_DIR}/README.md" << EOF
        # FortiGate Nextrade Offline Deployment Package
        
        Version: ${VERSION}
        Build Date: $(date -u +%Y-%m-%dT%H:%M:%SZ)
        Git SHA: ${GITHUB_SHA}
        
        ## Contents
        - \`images/\`: Docker container images
        - \`manifests/\`: Kubernetes deployment manifests
        - \`scripts/\`: Installation scripts
        - \`config/\`: Configuration files
        
        ## Installation Instructions
        
        ### 1. Load Docker Image
        \`\`\`bash
        docker load -i images/fortigate-nextrade.tar
        \`\`\`
        
        ### 2. Deploy to Kubernetes
        \`\`\`bash
        kubectl apply -k manifests/
        \`\`\`
        
        ### 3. Alternative: Run with Docker
        \`\`\`bash
        docker run -d --name fortigate-nextrade \\
          -p 7777:7777 \\
          -v \$(pwd)/config:/app/data \\
          -e APP_MODE=production \\
          fortigate-nextrade:latest
        \`\`\`
        
        ## Configuration
        Edit \`config/config.json\` before deployment to set your environment-specific values.
        
        EOF
        
        # 6. Create offline deployment script
        cat > "${TEMP_DIR}/deploy.sh" << 'EOF'
        #!/bin/bash
        set -e
        
        echo "ðŸš€ FortiGate Nextrade Offline Deployment"
        echo "========================================"
        
        # Check if Docker is available
        if command -v docker &> /dev/null; then
            echo "âœ… Docker found"
            echo "Loading Docker image..."
            docker load -i images/fortigate-nextrade.tar
            echo "âœ… Image loaded successfully"
        else
            echo "âŒ Docker not found. Please install Docker first."
            exit 1
        fi
        
        # Check if kubectl is available
        if command -v kubectl &> /dev/null; then
            echo "âœ… kubectl found"
            read -p "Deploy to Kubernetes? (y/n) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                kubectl apply -k manifests/
                echo "âœ… Deployed to Kubernetes"
            fi
        else
            echo "âš ï¸ kubectl not found. Skipping Kubernetes deployment."
        fi
        
        echo "ðŸŽ‰ Deployment package ready!"
        EOF
        
        chmod +x "${TEMP_DIR}/deploy.sh"
        
        # 7. Create tar.gz package
        echo "ðŸ—œï¸ Creating compressed package..."
        tar -czf "${PACKAGE_NAME}.tar.gz" "${PACKAGE_NAME}"
        
        # Calculate checksum
        SHA256SUM=$(sha256sum "${PACKAGE_NAME}.tar.gz" | awk '{print $1}')
        echo "${SHA256SUM}  ${PACKAGE_NAME}.tar.gz" > "${PACKAGE_NAME}.tar.gz.sha256"
        
        # Clean up
        rm -rf "${TEMP_DIR}"
        
        echo "âœ… Offline package created: ${PACKAGE_NAME}.tar.gz"
        echo "ðŸ“Š Size: $(ls -lh ${PACKAGE_NAME}.tar.gz | awk '{print $5}')"
        echo "ðŸ” SHA256: ${SHA256SUM}"
        
        # Set outputs for next steps
        echo "package_name=${PACKAGE_NAME}.tar.gz" >> $GITHUB_OUTPUT
        echo "package_sha256=${SHA256SUM}" >> $GITHUB_OUTPUT
        
    - name: ðŸ“¤ Upload Package Artifact
      uses: actions/upload-artifact@v4
      with:
        name: offline-deployment-package
        path: |
          fortinet-offline-deploy-*.tar.gz
          fortinet-offline-deploy-*.tar.gz.sha256
        retention-days: 30

  # GitHub Release ìƒì„±
  release:
    name: ðŸŽ Create Release
    needs: [build, offline-package]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
    - name: ðŸ“¥ Download Offline Package
      uses: actions/download-artifact@v4
      with:
        name: offline-deployment-package
        
    - name: ðŸŽ Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          fortinet-offline-deploy-*.tar.gz
          fortinet-offline-deploy-*.tar.gz.sha256
        generate_release_notes: true
        body: |
          ## ðŸš€ FortiGate Nextrade Release
          
          ### Docker Image
          - Registry: `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}`
          - Tag: `${{ github.ref_name }}`
          - Digest: `${{ needs.build.outputs.image-digest }}`
          
          ### Offline Deployment Package
          - Package includes all necessary files for air-gapped deployment
          - See README.md inside the package for installation instructions
          
          ### Changes
          See automated release notes below.
        draft: false
        prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'rc') }}

  # ì‹¤íŒ¨ ì‹œ Issue ìƒì„±
  create-issue-on-failure:
    name: ðŸš¨ Create Issue on Failure
    needs: [test, build, deploy, offline-package]
    runs-on: ubuntu-latest
    if: |
      always() && 
      github.event_name == 'push' &&
      (needs.test.result == 'failure' || 
       needs.build.result == 'failure' || 
       needs.deploy.result == 'failure' || 
       needs.offline-package.result == 'failure')
    
    steps:
    - name: ðŸ” Debug - Check Job Results
      run: |
        echo "ðŸ” Debugging Job Results:"
        echo "Test Result: ${{ needs.test.result }}"
        echo "Build Result: ${{ needs.build.result }}"
        echo "Deploy Result: ${{ needs.deploy.result }}"
        echo "Offline Package Result: ${{ needs.offline-package.result }}"
        echo "Event Name: ${{ github.event_name }}"
        echo "Actor: ${{ github.actor }}"
        echo "Ref: ${{ github.ref }}"
    - name: ðŸ“¥ Checkout
      uses: actions/checkout@v4
      
    - name: ðŸ” Check for Existing Issues
      id: check-issues
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          try {
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const workflow_run_id = context.runId;
            const commit_sha = context.sha.substring(0, 7);
            
            console.log(`Checking for existing issues in ${owner}/${repo}`);
            console.log(`Workflow Run ID: ${workflow_run_id}`);
            console.log(`Commit SHA: ${commit_sha}`);
            
            // Search for existing open issues with same error
            const issues = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: 'ci-failure,automated'
            });
            
            console.log(`Found ${issues.data.length} open issues with labels ci-failure,automated`);
            
            // Check if issue already exists for this workflow run or commit
            const existingIssue = issues.data.find(issue => 
              issue.body && (issue.body.includes(workflow_run_id) || 
              issue.title.includes(commit_sha))
            );
            
            if (existingIssue) {
              console.log(`Found existing issue: #${existingIssue.number}`);
              core.setOutput('issue_exists', 'true');
              core.setOutput('issue_number', existingIssue.number);
            } else {
              console.log('No existing issue found');
              core.setOutput('issue_exists', 'false');
            }
          } catch (error) {
            console.error('Error checking for existing issues:', error);
            core.setOutput('issue_exists', 'false');
          }
          
    - name: ðŸ“ Collect Failure Information & Logs
      if: steps.check-issues.outputs.issue_exists == 'false'
      id: collect-info
      run: |
        # Determine which jobs failed
        FAILED_JOBS=""
        if [[ "${{ needs.test.result }}" == "failure" ]]; then
          FAILED_JOBS="${FAILED_JOBS}test, "
        fi
        if [[ "${{ needs.build.result }}" == "failure" ]]; then
          FAILED_JOBS="${FAILED_JOBS}build, "
        fi
        if [[ "${{ needs.deploy.result }}" == "failure" ]]; then
          FAILED_JOBS="${FAILED_JOBS}deploy, "
        fi
        if [[ "${{ needs.offline-package.result }}" == "failure" ]]; then
          FAILED_JOBS="${FAILED_JOBS}offline-package, "
        fi
        
        # Remove trailing comma
        FAILED_JOBS=${FAILED_JOBS%, }
        
        # Create error signature for duplicate detection
        ERROR_SIGNATURE="${{ github.ref_name }}-${FAILED_JOBS// /-}"
        
        echo "failed_jobs=${FAILED_JOBS}" >> $GITHUB_OUTPUT
        echo "workflow_url=https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> $GITHUB_OUTPUT
        echo "error_signature=${ERROR_SIGNATURE}" >> $GITHUB_OUTPUT
        
    - name: ðŸ“ Create Issue Content
      if: steps.check-issues.outputs.issue_exists == 'false'
      run: |
        mkdir -p .github/ISSUE_TEMPLATE
        cat > .github/ISSUE_TEMPLATE/ci-failure-content.md << 'EOF'
        ## CI/CD Pipeline Failure Report
        
        ### ðŸ“‹ Summary
        The CI/CD pipeline has failed for commit `${{ github.sha }}`.
        
        ### ðŸ”´ Failed Jobs
        - **Failed Jobs**: ${{ steps.collect-info.outputs.failed_jobs }}
        - **Workflow Run ID**: ${{ github.run_id }}
        - **Triggered by**: @${{ github.actor }}
        - **Branch**: `${{ github.ref_name }}`
        
        ### ðŸ“ Commit Information
        - **SHA**: `${{ github.sha }}`
        - **Message**: ${{ github.event.head_commit.message }}
        
        ### ðŸ”— Links
        - [View Workflow Run](${{ steps.collect-info.outputs.workflow_url }})
        - [View Commit](https://github.com/${{ github.repository }}/commit/${{ github.sha }})
        
        ### ðŸ“Š Job Results
        - Test: ${{ needs.test.result }}
        - Build: ${{ needs.build.result }}
        - Deploy: ${{ needs.deploy.result }}
        - Offline Package: ${{ needs.offline-package.result }}
        
        ### ðŸ”§ Suggested Actions
        1. Check the workflow logs for detailed error messages
        2. Review the commit changes that triggered this failure
        3. Fix the issues and push a new commit
        4. Close this issue once the pipeline is green
        
        ### ðŸ”— Quick Links
        - [Workflow Run Logs](${{ steps.collect-info.outputs.workflow_url }})
        - [ArgoCD Dashboard](https://argo.jclee.me/applications/fortinet)
        - [Application URL](https://fortinet.jclee.me/)
        
        ---
        *This issue was automatically created by GitHub Actions*
        EOF
        
    - name: ðŸš¨ Create Issue
      if: steps.check-issues.outputs.issue_exists == 'false'
      uses: peter-evans/create-issue-from-file@v5
      with:
        title: ðŸš¨ CI/CD Pipeline Failed - ${{ steps.collect-info.outputs.failed_jobs }} - ${{ github.ref_name }}
        labels: |
          ci-failure
          automated
          bug
        assignees: ${{ github.actor }}
        content-filepath: .github/ISSUE_TEMPLATE/ci-failure-content.md
          
    - name: ðŸ’¬ Comment on Existing Issue
      if: steps.check-issues.outputs.issue_exists == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const issue_number = parseInt('${{ steps.check-issues.outputs.issue_number }}');
          const workflow_url = 'https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}';
          const commit_sha = context.sha;
          const actor = '${{ github.actor }}';
          
          const comment = `## ðŸ”„ Pipeline Failed Again
          
          Another pipeline failure occurred for commit \`${commit_sha.substring(0, 7)}\`.
          
          - **Triggered by**: @${actor}
          - **Workflow Run**: [View Run](${workflow_url})
          - **Timestamp**: ${new Date().toISOString()}
          
          Please check the latest failure logs.`;
          
          await github.rest.issues.createComment({
            owner,
            repo,
            issue_number,
            body: comment
          });
          
          console.log(`Added comment to existing issue #${issue_number}`);

  # ì•Œë¦¼
  notify:
    name: ðŸ“¢ Notify
    needs: [test, build, deploy, offline-package, create-issue-on-failure]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: ðŸ“Š Summary
      run: |
        echo "## Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "- Test: ${{ needs.test.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Build: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Deploy: ${{ needs.deploy.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Offline Package: ${{ needs.offline-package.result }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Author**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.offline-package.result }}" == "success" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Offline Package" >> $GITHUB_STEP_SUMMARY
          echo "- Package: ${{ needs.offline-package.outputs.package_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- SHA256: ${{ needs.offline-package.outputs.package_sha256 }}" >> $GITHUB_STEP_SUMMARY
        fi