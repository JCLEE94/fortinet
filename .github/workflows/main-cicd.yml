name: Main CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop ]
    tags: [ 'v*' ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [ main, master ]

# Ï§ëÎ≥µ Ïã§Ìñâ Î∞©ÏßÄ
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ${{ vars.DOCKER_REGISTRY || 'registry.jclee.me' }}
  IMAGE_NAME: ${{ vars.DOCKER_IMAGE_NAME || 'fortinet' }}
  PYTHON_VERSION: '3.11'
  DEPLOY_METHOD: ${{ vars.DEPLOY_METHOD || 'argocd' }}  # argocd, k8s-direct

jobs:
  # ÌÖåÏä§Ìä∏ Î∞è ÌíàÏßà Í≤ÄÏÇ¨
  test:
    name: üß™ Test & Quality
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4
      
    - name: üêç Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: üì¶ Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov black flake8 mypy
        
    - name: üîç Code Quality
      run: |
        echo "Running code quality checks..."
        black --check src/ || true
        flake8 src/ --max-line-length=120 --ignore=E203,W503 || true
        mypy src/ --ignore-missing-imports || true
        
    - name: üß™ Run Tests
      run: |
        cd src
        python -m pytest ../tests/ -v || echo "Some tests failed"

  # Docker ÎπåÎìú
  build:
    name: üèóÔ∏è Build & Push
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4
      
    - name: üè∑Ô∏è Docker Meta
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: üîê Registry Login
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}
        
    - name: üèóÔ∏è Build and Push
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.production
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          VCS_REF=${{ github.sha }}
          VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}

  # Î∞∞Ìè¨
  deploy:
    name: üöÄ Deploy
    needs: build
    runs-on: self-hosted
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4
      
    - name: üîß Setup Environment
      run: |
        echo "üìã Deployment Configuration:"
        echo "Method: ${{ env.DEPLOY_METHOD }}"
        echo "Image: ${{ needs.build.outputs.image-tag }}"
        echo "Registry: ${{ env.REGISTRY }}"
        
        
    # K8s ÏßÅÏ†ë Î∞∞Ìè¨
    - name: ‚ò∏Ô∏è Deploy to K8s
      if: env.DEPLOY_METHOD == 'k8s-direct'
      run: |
        echo "‚ò∏Ô∏è Deploying to Kubernetes..."
        kubectl set image deployment/fortinet-app \
          fortinet=${{ needs.build.outputs.image-tag }} \
          -n fortinet
        kubectl rollout status deployment/fortinet-app -n fortinet
        
    # ArgoCD CLI ÏÑ§Ïπò
    - name: üì¶ Install ArgoCD CLI
      if: env.DEPLOY_METHOD == 'argocd'
      run: |
        echo "üì¶ Installing ArgoCD CLI..."
        curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
        chmod +x argocd
        sudo mv argocd /usr/local/bin/argocd
        argocd version --client

    # ArgoCD Î∞∞Ìè¨ (Í∏∞Î≥∏)
    - name: üéØ Deploy via ArgoCD
      if: env.DEPLOY_METHOD == 'argocd'
      env:
        ARGOCD_SERVER: argo.jclee.me
        ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
        ARGOCD_OPTS: --grpc-web
      run: |
        echo "üéØ Deploying via ArgoCD..."
        
        # Extract image tag from build output
        IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tag }}" | grep "latest" | head -n1)
        SHORT_SHA="${{ github.sha }}"
        
        echo "Image tag: $IMAGE_TAG"
        echo "Short SHA: $SHORT_SHA"
        
        # Update kustomization.yaml with new image tag and timestamp
        sed -i "s|newTag:.*|newTag: $SHORT_SHA|g" k8s/manifests/kustomization.yaml
        
        # Add deployment metadata
        if ! grep -q "commonAnnotations:" k8s/manifests/kustomization.yaml; then
          echo "" >> k8s/manifests/kustomization.yaml
          echo "commonAnnotations:" >> k8s/manifests/kustomization.yaml
          echo "  app.kubernetes.io/version: \"$SHORT_SHA\"" >> k8s/manifests/kustomization.yaml
          echo "  deployed-by: \"github-actions\"" >> k8s/manifests/kustomization.yaml
          echo "  deployed-at: \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"" >> k8s/manifests/kustomization.yaml
        else
          sed -i "s|app.kubernetes.io/version:.*|app.kubernetes.io/version: \"$SHORT_SHA\"|g" k8s/manifests/kustomization.yaml
          sed -i "s|deployed-at:.*|deployed-at: \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"|g" k8s/manifests/kustomization.yaml
        fi
        
        # Commit and push changes
        git config user.name "GitHub Actions Bot"
        git config user.email "actions@github.com"
        git add k8s/manifests/kustomization.yaml
        
        if ! git diff --cached --quiet; then
          git commit -m "üöÄ Update image tag to $SHORT_SHA

          üìã Deployment Info:
          - Triggered by: ${{ github.event_name }}
          - Branch: ${{ github.ref_name }}
          - Actor: ${{ github.actor }}
          - Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$SHORT_SHA
          - Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          
          ü§ñ Auto-generated by GitHub Actions"
          
          git push origin HEAD:${{ github.ref_name }}
          echo "‚úÖ Git changes pushed successfully"
        else
          echo "‚ÑπÔ∏è No changes to commit"
        fi
        
        # Wait for git to propagate
        sleep 5
        
        # Trigger ArgoCD sync via API
        echo "üîÑ Triggering ArgoCD sync..."
        SYNC_RESPONSE=$(curl -s -X POST "https://argo.jclee.me/api/v1/applications/${{ vars.ARGOCD_APP_NAME || 'fortinet' }}/sync" \
          -H "Authorization: Bearer ${{ secrets.ARGOCD_AUTH_TOKEN }}" \
          -H "Content-Type: application/json" \
          -d '{
            "prune": true, 
            "dryRun": false,
            "strategy": {
              "hook": {"force": true}
            },
            "syncOptions": {
              "items": ["CreateNamespace=true", "PrunePropagationPolicy=foreground"]
            }
          }' \
          --fail -w "%{http_code}" || echo "SYNC_FAILED")
          
        if [[ "$SYNC_RESPONSE" == *"200"* ]] || [[ "$SYNC_RESPONSE" == *"202"* ]]; then
          echo "‚úÖ ArgoCD sync triggered successfully"
        else
          echo "‚ö†Ô∏è ArgoCD API sync failed (HTTP: $SYNC_RESPONSE), relying on auto-sync"
        fi
        
        # Get application status
        echo "üìä Checking ArgoCD application status..."
        argocd app get ${{ vars.ARGOCD_APP_NAME || 'fortinet' }} --grpc-web || echo "Status check failed"
        
    # Ìó¨Ïä§ Ï≤¥ÌÅ¨
    - name: üè• Health Check
      if: always()
      run: |
        echo "üè• Running health check..."
        sleep 60  # Wait for deployment
        
        # Check application health
        for i in {1..5}; do
          if curl -f -k -s https://fortinet.jclee.me/api/health; then
            echo "‚úÖ Application is healthy!"
            break
          fi
          echo "Attempt $i/5 failed, waiting..."
          sleep 30
        done

  # Ïò§ÌîÑÎùºÏù∏ Ìå®ÌÇ§ÏßÄ ÏÉùÏÑ±
  offline-package:
    name: üì¶ Create Offline Package
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || startsWith(github.ref, 'refs/tags/'))
    
    outputs:
      package_name: ${{ steps.create-package.outputs.package_name }}
      package_sha256: ${{ steps.create-package.outputs.package_sha256 }}
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4
      
    - name: üîê Registry Login
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}
        
    - name: üê≥ Pull Built Image
      run: |
        # Extract the first tag from build output
        IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tag }}" | cut -d',' -f1 | xargs)
        echo "Pulling image: $IMAGE_TAG"
        docker pull $IMAGE_TAG
        docker tag $IMAGE_TAG fortigate-nextrade:latest
        
    - name: üì¶ Create Offline Package
      id: create-package
      run: |
        echo "üîß Creating offline deployment package..."
        
        # Set variables
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        VERSION="${{ github.ref_name }}-${GITHUB_SHA:0:7}"
        PACKAGE_NAME="fortinet-offline-deploy-${VERSION}-${TIMESTAMP}"
        TEMP_DIR="./${PACKAGE_NAME}"
        
        # Create temp directory
        mkdir -p "${TEMP_DIR}"
        
        # Create directories structure
        mkdir -p "${TEMP_DIR}/images"
        mkdir -p "${TEMP_DIR}/manifests"
        mkdir -p "${TEMP_DIR}/scripts"
        mkdir -p "${TEMP_DIR}/config"
        
        # 1. Save Docker image
        echo "üíæ Saving Docker image..."
        docker save -o "${TEMP_DIR}/images/fortigate-nextrade.tar" fortigate-nextrade:latest
        
        # 2. Copy Kubernetes manifests
        echo "üìã Copying Kubernetes manifests..."
        cp -r k8s/manifests/* "${TEMP_DIR}/manifests/"
        
        # 3. Copy deployment scripts
        echo "üìù Copying deployment scripts..."
        if [ -f "deploy/installers/fortinet-installer.sh" ]; then
          cp deploy/installers/fortinet-installer.sh "${TEMP_DIR}/scripts/"
        fi
        if [ -f "deploy/installers/fortinet-installer.ps1" ]; then
          cp deploy/installers/fortinet-installer.ps1 "${TEMP_DIR}/scripts/"
        fi
        
        # 4. Copy configuration files
        echo "‚öôÔ∏è Copying configuration files..."
        if [ -d "data" ]; then
          cp -r data/*.json "${TEMP_DIR}/config/" 2>/dev/null || echo "No JSON config files found"
        fi
        
        # Create a default config.json if not exists
        if [ ! -f "${TEMP_DIR}/config/config.json" ]; then
          echo '{"app_mode": "production", "offline_mode": true}' > "${TEMP_DIR}/config/config.json"
        fi
        
        # 5. Create deployment instructions
        cat > "${TEMP_DIR}/README.md" << EOF
        # FortiGate Nextrade Offline Deployment Package
        
        Version: ${VERSION}
        Build Date: $(date -u +%Y-%m-%dT%H:%M:%SZ)
        Git SHA: ${GITHUB_SHA}
        
        ## Contents
        - \`images/\`: Docker container images
        - \`manifests/\`: Kubernetes deployment manifests
        - \`scripts/\`: Installation scripts
        - \`config/\`: Configuration files
        
        ## Installation Instructions
        
        ### 1. Load Docker Image
        \`\`\`bash
        docker load -i images/fortigate-nextrade.tar
        \`\`\`
        
        ### 2. Deploy to Kubernetes
        \`\`\`bash
        kubectl apply -k manifests/
        \`\`\`
        
        ### 3. Alternative: Run with Docker
        \`\`\`bash
        docker run -d --name fortigate-nextrade \\
          -p 7777:7777 \\
          -v \$(pwd)/config:/app/data \\
          -e APP_MODE=production \\
          fortigate-nextrade:latest
        \`\`\`
        
        ## Configuration
        Edit \`config/config.json\` before deployment to set your environment-specific values.
        
        EOF
        
        # 6. Create offline deployment script
        cat > "${TEMP_DIR}/deploy.sh" << 'EOF'
        #!/bin/bash
        set -e
        
        echo "üöÄ FortiGate Nextrade Offline Deployment"
        echo "========================================"
        
        # Check if Docker is available
        if command -v docker &> /dev/null; then
            echo "‚úÖ Docker found"
            echo "Loading Docker image..."
            docker load -i images/fortigate-nextrade.tar
            echo "‚úÖ Image loaded successfully"
        else
            echo "‚ùå Docker not found. Please install Docker first."
            exit 1
        fi
        
        # Check if kubectl is available
        if command -v kubectl &> /dev/null; then
            echo "‚úÖ kubectl found"
            read -p "Deploy to Kubernetes? (y/n) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                kubectl apply -k manifests/
                echo "‚úÖ Deployed to Kubernetes"
            fi
        else
            echo "‚ö†Ô∏è kubectl not found. Skipping Kubernetes deployment."
        fi
        
        echo "üéâ Deployment package ready!"
        EOF
        
        chmod +x "${TEMP_DIR}/deploy.sh"
        
        # 7. Create tar.gz package
        echo "üóúÔ∏è Creating compressed package..."
        tar -czf "${PACKAGE_NAME}.tar.gz" "${PACKAGE_NAME}"
        
        # Calculate checksum
        SHA256SUM=$(sha256sum "${PACKAGE_NAME}.tar.gz" | awk '{print $1}')
        echo "${SHA256SUM}  ${PACKAGE_NAME}.tar.gz" > "${PACKAGE_NAME}.tar.gz.sha256"
        
        # Clean up
        rm -rf "${TEMP_DIR}"
        
        echo "‚úÖ Offline package created: ${PACKAGE_NAME}.tar.gz"
        echo "üìä Size: $(ls -lh ${PACKAGE_NAME}.tar.gz | awk '{print $5}')"
        echo "üîê SHA256: ${SHA256SUM}"
        
        # Set outputs for next steps
        echo "package_name=${PACKAGE_NAME}.tar.gz" >> $GITHUB_OUTPUT
        echo "package_sha256=${SHA256SUM}" >> $GITHUB_OUTPUT
        
    - name: üì§ Upload Package Artifact
      uses: actions/upload-artifact@v4
      with:
        name: offline-deployment-package
        path: |
          fortinet-offline-deploy-*.tar.gz
          fortinet-offline-deploy-*.tar.gz.sha256
        retention-days: 30

  # GitHub Release ÏÉùÏÑ±
  release:
    name: üéÅ Create Release
    needs: [build, offline-package]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
    - name: üì• Download Offline Package
      uses: actions/download-artifact@v4
      with:
        name: offline-deployment-package
        
    - name: üéÅ Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          fortinet-offline-deploy-*.tar.gz
          fortinet-offline-deploy-*.tar.gz.sha256
        generate_release_notes: true
        body: |
          ## üöÄ FortiGate Nextrade Release
          
          ### Docker Image
          - Registry: `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}`
          - Tag: `${{ github.ref_name }}`
          - Digest: `${{ needs.build.outputs.image-digest }}`
          
          ### Offline Deployment Package
          - Package includes all necessary files for air-gapped deployment
          - See README.md inside the package for installation instructions
          
          ### Changes
          See automated release notes below.
        draft: false
        prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'rc') }}

  # ÏïåÎ¶º
  notify:
    name: üì¢ Notify
    needs: [test, build, deploy, offline-package]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: üìä Summary
      run: |
        echo "## Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "- Test: ${{ needs.test.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Build: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Deploy: ${{ needs.deploy.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Offline Package: ${{ needs.offline-package.result }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Author**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.offline-package.result }}" == "success" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Offline Package" >> $GITHUB_STEP_SUMMARY
          echo "- Package: ${{ needs.offline-package.outputs.package_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- SHA256: ${{ needs.offline-package.outputs.package_sha256 }}" >> $GITHUB_STEP_SUMMARY
        fi