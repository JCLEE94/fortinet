name: 📦 Offline Package Builder

on:
  workflow_dispatch:
    inputs:
      package_type:
        description: 'Package Type'
        required: true
        default: 'full'
        type: choice
        options:
          - full           # Complete package with all dependencies
          - minimal        # App only, no dependencies
          - docker         # Docker images bundle
          - k8s           # Kubernetes manifests bundle
      include_dependencies:
        description: 'Include Dependencies'
        required: true
        default: 'all'
        type: choice
        options:
          - all           # All dependencies
          - python        # Python packages only
          - system        # System packages only
          - none          # No dependencies
      compression:
        description: 'Compression Method'
        required: true
        default: 'tar.gz'
        type: choice
        options:
          - tar.gz        # Standard compression
          - tar.xz        # High compression
          - zip           # Windows compatible
      target_platform:
        description: 'Target Platform'
        required: true
        default: 'linux'
        type: choice
        options:
          - linux
          - windows
          - macos
          - all

env:
  PROJECT_NAME: fortinet
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  PACKAGE_PREFIX: fortinet-offline

jobs:
  # ===========================
  # PREPARE PACKAGE
  # ===========================
  prepare:
    name: 📋 Prepare Package
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      package_id: ${{ steps.version.outputs.package_id }}
      manifest: ${{ steps.manifest.outputs.content }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Generate version info
        id: version
        run: |
          # Generate package version
          VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
          BUILD_DATE=$(date -u +'%Y%m%d')
          BUILD_TIME=$(date -u +'%H%M%S')
          COMMIT_SHA="${{ github.sha }}"
          PACKAGE_ID="${VERSION}-${BUILD_DATE}-${BUILD_TIME}"
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT
          echo "build_time=$BUILD_TIME" >> $GITHUB_OUTPUT
          echo "package_id=$PACKAGE_ID" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
      
      - name: Create package manifest
        id: manifest
        run: |
          # Create manifest JSON
          cat > manifest.json << EOF
          {
            "package": {
              "name": "${{ env.PROJECT_NAME }}",
              "version": "${{ steps.version.outputs.version }}",
              "package_id": "${{ steps.version.outputs.package_id }}",
              "type": "${{ github.event.inputs.package_type }}",
              "platform": "${{ github.event.inputs.target_platform }}",
              "build": {
                "date": "${{ steps.version.outputs.build_date }}",
                "time": "${{ steps.version.outputs.build_time }}",
                "commit": "${{ steps.version.outputs.commit_sha }}",
                "branch": "${{ github.ref_name }}",
                "builder": "GitHub Actions",
                "run_id": "${{ github.run_id }}"
              },
              "options": {
                "dependencies": "${{ github.event.inputs.include_dependencies }}",
                "compression": "${{ github.event.inputs.compression }}"
              }
            },
            "requirements": {
              "python": "${{ env.PYTHON_VERSION }}",
              "node": "${{ env.NODE_VERSION }}",
              "docker": "20.10+",
              "kubernetes": "1.24+"
            }
          }
          EOF
          
          echo "content=$(cat manifest.json | jq -c .)" >> $GITHUB_OUTPUT
      
      - name: Create package structure
        run: |
          # Create directory structure
          mkdir -p package/{app,deps,docker,k8s,scripts,docs,config,data}
          
          # Copy manifest
          cp manifest.json package/
          
          # Create VERSION file
          cat > package/VERSION << EOF
          Package: ${{ env.PROJECT_NAME }}
          Version: ${{ steps.version.outputs.version }}
          Build ID: ${{ steps.version.outputs.package_id }}
          Type: ${{ github.event.inputs.package_type }}
          Platform: ${{ github.event.inputs.target_platform }}
          Date: ${{ steps.version.outputs.build_date }}
          Commit: ${{ github.sha }}
          EOF
      
      - name: Upload package structure
        uses: actions/upload-artifact@v4
        with:
          name: package-base
          path: package/
          retention-days: 1

  # ===========================
  # BUILD APPLICATION
  # ===========================
  build-app:
    name: 🔨 Build Application
    runs-on: ubuntu-latest
    needs: prepare
    if: |
      github.event.inputs.package_type == 'full' ||
      github.event.inputs.package_type == 'minimal'
    steps:
      - uses: actions/checkout@v4
      
      - name: Download package base
        uses: actions/download-artifact@v4
        with:
          name: package-base
          path: package/
      
      - name: Prepare application files
        run: |
          # Copy source code
          cp -r src package/app/
          cp -r templates package/app/
          cp -r static package/app/
          
          # Copy configuration files
          cp requirements*.txt package/app/
          cp *.py package/app/ 2>/dev/null || true
          cp pyproject.toml package/app/ 2>/dev/null || true
          cp setup.py package/app/ 2>/dev/null || true
          
          # Copy data files
          cp -r data package/ 2>/dev/null || true
          
          # Copy documentation
          cp README.md package/docs/
          cp -r docs/* package/docs/ 2>/dev/null || true
          
          # Create offline configuration
          cat > package/config/offline.json << EOF
          {
            "offline_mode": true,
            "mock_mode": true,
            "app_mode": "test",
            "disable_external_calls": true,
            "web_app_port": 7777,
            "api_base_url": "http://localhost:7777",
            "fortigate_host": "192.168.1.1",
            "fortimanager_host": "192.168.1.2"
          }
          EOF
      
      - name: Create startup scripts
        run: |
          # Create cross-platform startup script
          cat > package/scripts/start.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "========================================"
          echo "Fortinet Offline Application Starter"
          echo "========================================"
          
          # Check Python installation
          if ! command -v python3 &> /dev/null; then
              echo "Error: Python 3 is not installed"
              exit 1
          fi
          
          # Set environment variables
          export OFFLINE_MODE=true
          export APP_MODE=test
          export PYTHONPATH="${PYTHONPATH}:$(pwd)/app"
          
          # Start application
          cd app
          python3 src/main.py --web
          EOF
          chmod +x package/scripts/start.sh
          
          # Windows batch script
          cat > package/scripts/start.bat << 'EOF'
          @echo off
          echo ========================================
          echo Fortinet Offline Application Starter
          echo ========================================
          
          REM Check Python installation
          python --version >nul 2>&1
          if errorlevel 1 (
              echo Error: Python is not installed
              exit /b 1
          )
          
          REM Set environment variables
          set OFFLINE_MODE=true
          set APP_MODE=test
          set PYTHONPATH=%PYTHONPATH%;%cd%\app
          
          REM Start application
          cd app
          python src\main.py --web
          EOF
      
      - name: Upload application package
        uses: actions/upload-artifact@v4
        with:
          name: package-app
          path: package/
          retention-days: 1

  # ===========================
  # BUILD DEPENDENCIES
  # ===========================
  build-deps:
    name: 📦 Build Dependencies
    runs-on: ubuntu-latest
    needs: prepare
    if: |
      github.event.inputs.include_dependencies != 'none' &&
      (github.event.inputs.package_type == 'full' || 
       github.event.inputs.package_type == 'minimal')
    strategy:
      matrix:
        platform: [linux, windows, macos]
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Download package base
        uses: actions/download-artifact@v4
        with:
          name: package-base
          path: package/
      
      - name: Build Python dependencies
        if: |
          github.event.inputs.include_dependencies == 'all' ||
          github.event.inputs.include_dependencies == 'python'
        run: |
          # Create platform-specific directory
          mkdir -p package/deps/${{ matrix.platform }}/python
          
          # Download wheels for platform
          pip download \
            --platform ${{ matrix.platform == 'linux' && 'manylinux2014_x86_64' || matrix.platform }} \
            --only-binary :all: \
            -r requirements.txt \
            -d package/deps/${{ matrix.platform }}/python/
          
          # Create requirements with hashes
          pip freeze > package/deps/${{ matrix.platform }}/python/requirements-frozen.txt
          
          # Create installation script
          cat > package/deps/${{ matrix.platform }}/install-python.sh << 'EOF'
          #!/bin/bash
          echo "Installing Python dependencies..."
          pip install --no-index --find-links ./python -r ./python/requirements-frozen.txt
          echo "Python dependencies installed!"
          EOF
          chmod +x package/deps/${{ matrix.platform }}/install-python.sh
      
      - name: Collect system dependencies
        if: |
          github.event.inputs.include_dependencies == 'all' ||
          github.event.inputs.include_dependencies == 'system'
        run: |
          # Create system deps list
          mkdir -p package/deps/${{ matrix.platform }}/system
          
          # Platform-specific system dependencies
          case "${{ matrix.platform }}" in
            linux)
              cat > package/deps/${{ matrix.platform }}/system/packages.txt << EOF
          python3-pip
          python3-venv
          git
          curl
          wget
          build-essential
          libssl-dev
          libffi-dev
          EOF
              ;;
            macos)
              cat > package/deps/${{ matrix.platform }}/system/packages.txt << EOF
          python3
          git
          curl
          wget
          openssl
          libffi
          EOF
              ;;
            windows)
              cat > package/deps/${{ matrix.platform }}/system/packages.txt << EOF
          python
          git
          curl
          EOF
              ;;
          esac
      
      - name: Upload dependencies
        uses: actions/upload-artifact@v4
        with:
          name: package-deps-${{ matrix.platform }}
          path: package/deps/${{ matrix.platform }}/
          retention-days: 1

  # ===========================
  # BUILD DOCKER BUNDLE
  # ===========================
  build-docker:
    name: 🐳 Build Docker Bundle
    runs-on: ubuntu-latest
    needs: prepare
    if: |
      github.event.inputs.package_type == 'full' ||
      github.event.inputs.package_type == 'docker'
    steps:
      - uses: actions/checkout@v4
      
      - name: Download package base
        uses: actions/download-artifact@v4
        with:
          name: package-base
          path: package/
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build Docker images
        run: |
          # Build production image
          docker build -f Dockerfile.production -t ${{ env.PROJECT_NAME }}:offline-${{ needs.prepare.outputs.version }} .
          
          # Build development image if exists
          if [ -f Dockerfile.development ]; then
            docker build -f Dockerfile.development -t ${{ env.PROJECT_NAME }}:offline-dev-${{ needs.prepare.outputs.version }} .
          fi
          
          # Save images as tar
          docker save \
            ${{ env.PROJECT_NAME }}:offline-${{ needs.prepare.outputs.version }} \
            -o package/docker/fortinet-images.tar
          
          # Compress if needed
          case "${{ github.event.inputs.compression }}" in
            tar.gz)
              gzip -9 package/docker/fortinet-images.tar
              mv package/docker/fortinet-images.tar.gz package/docker/
              ;;
            tar.xz)
              xz -9 package/docker/fortinet-images.tar
              mv package/docker/fortinet-images.tar.xz package/docker/
              ;;
          esac
      
      - name: Create Docker scripts
        run: |
          # Load images script
          cat > package/docker/load-images.sh << 'EOF'
          #!/bin/bash
          echo "Loading Docker images..."
          
          # Detect compression and load
          if [ -f fortinet-images.tar.gz ]; then
              docker load < fortinet-images.tar.gz
          elif [ -f fortinet-images.tar.xz ]; then
              docker load < fortinet-images.tar.xz
          elif [ -f fortinet-images.tar ]; then
              docker load < fortinet-images.tar
          else
              echo "No Docker images found!"
              exit 1
          fi
          
          echo "Docker images loaded successfully!"
          docker images | grep fortinet
          EOF
          chmod +x package/docker/load-images.sh
          
          # Docker Compose file
          cat > package/docker/docker-compose.yml << EOF
          version: '3.8'
          
          services:
            fortinet:
              image: ${{ env.PROJECT_NAME }}:offline-${{ needs.prepare.outputs.version }}
              container_name: fortinet-offline
              ports:
                - "7777:7777"
              environment:
                - OFFLINE_MODE=true
                - APP_MODE=test
              volumes:
                - ./data:/app/data
                - ./config:/app/config
              restart: unless-stopped
          EOF
      
      - name: Upload Docker bundle
        uses: actions/upload-artifact@v4
        with:
          name: package-docker
          path: package/docker/
          retention-days: 1

  # ===========================
  # BUILD K8S BUNDLE
  # ===========================
  build-k8s:
    name: ☸️ Build K8s Bundle
    runs-on: ubuntu-latest
    needs: prepare
    if: |
      github.event.inputs.package_type == 'full' ||
      github.event.inputs.package_type == 'k8s'
    steps:
      - uses: actions/checkout@v4
      
      - name: Download package base
        uses: actions/download-artifact@v4
        with:
          name: package-base
          path: package/
      
      - name: Prepare K8s manifests
        run: |
          # Copy K8s manifests
          if [ -d k8s ]; then
            cp -r k8s/* package/k8s/
          fi
          
          if [ -d charts ]; then
            cp -r charts package/k8s/
          fi
          
          # Update image references for offline
          find package/k8s -name "*.yaml" -o -name "*.yml" | while read file; do
            sed -i "s|registry.jclee.me/.*:.*|${{ env.PROJECT_NAME }}:offline-${{ needs.prepare.outputs.version }}|g" "$file"
          done
          
          # Create kustomization for offline
          cat > package/k8s/kustomization.yaml << EOF
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization
          
          namespace: fortinet
          
          resources:
            - namespace.yaml
            - deployment.yaml
            - service.yaml
            - configmap.yaml
          
          images:
            - name: fortinet
              newName: ${{ env.PROJECT_NAME }}
              newTag: offline-${{ needs.prepare.outputs.version }}
          
          configMapGenerator:
            - name: fortinet-config
              literals:
                - OFFLINE_MODE=true
                - APP_MODE=test
          EOF
      
      - name: Create deployment scripts
        run: |
          # Kubernetes deployment script
          cat > package/k8s/deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "Deploying Fortinet to Kubernetes (Offline Mode)"
          echo "================================================"
          
          # Check kubectl
          if ! command -v kubectl &> /dev/null; then
              echo "Error: kubectl is not installed"
              exit 1
          fi
          
          # Create namespace
          kubectl create namespace fortinet --dry-run=client -o yaml | kubectl apply -f -
          
          # Apply manifests
          if [ -f kustomization.yaml ]; then
              echo "Applying with Kustomize..."
              kubectl apply -k .
          else
              echo "Applying manifests..."
              kubectl apply -f . -n fortinet
          fi
          
          # Wait for deployment
          echo "Waiting for deployment to be ready..."
          kubectl rollout status deployment/fortinet -n fortinet --timeout=300s
          
          # Show status
          echo ""
          echo "Deployment Status:"
          kubectl get all -n fortinet
          
          echo ""
          echo "To access the application:"
          echo "kubectl port-forward -n fortinet svc/fortinet-service 7777:7777"
          EOF
          chmod +x package/k8s/deploy.sh
          
          # Helm install script
          if [ -d package/k8s/charts ]; then
            cat > package/k8s/helm-deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "Installing Fortinet with Helm (Offline Mode)"
          
          # Check helm
          if ! command -v helm &> /dev/null; then
              echo "Error: helm is not installed"
              exit 1
          fi
          
          # Install/upgrade
          helm upgrade --install fortinet ./charts/fortinet \
            --namespace fortinet \
            --create-namespace \
            --set image.tag=offline-${{ needs.prepare.outputs.version }} \
            --set offline.enabled=true \
            --wait
          
          echo "Helm installation complete!"
          EOF
            chmod +x package/k8s/helm-deploy.sh
          fi
      
      - name: Upload K8s bundle
        uses: actions/upload-artifact@v4
        with:
          name: package-k8s
          path: package/k8s/
          retention-days: 1

  # ===========================
  # ASSEMBLE FINAL PACKAGE
  # ===========================
  assemble:
    name: 📦 Assemble Final Package
    runs-on: ubuntu-latest
    needs: [prepare, build-app, build-deps, build-docker, build-k8s]
    if: always()
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
      
      - name: Assemble package
        run: |
          # Create final package directory
          mkdir -p final-package
          
          # Merge all artifacts
          for artifact in artifacts/package-*; do
            if [ -d "$artifact" ]; then
              cp -r "$artifact"/* final-package/ 2>/dev/null || true
            fi
          done
          
          # Handle platform-specific dependencies
          if [ "${{ github.event.inputs.target_platform }}" == "all" ]; then
            # Include all platforms
            for platform in linux windows macos; do
              if [ -d "artifacts/package-deps-$platform" ]; then
                mkdir -p final-package/deps/$platform
                cp -r "artifacts/package-deps-$platform"/* final-package/deps/$platform/
              fi
            done
          else
            # Include specific platform only
            if [ -d "artifacts/package-deps-${{ github.event.inputs.target_platform }}" ]; then
              mkdir -p final-package/deps
              cp -r "artifacts/package-deps-${{ github.event.inputs.target_platform }}"/* final-package/deps/
            fi
          fi
      
      - name: Create master installer
        run: |
          cat > final-package/install.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "============================================"
          echo "   Fortinet Offline Package Installer"
          echo "============================================"
          echo ""
          
          # Read manifest
          if [ -f manifest.json ]; then
              VERSION=$(jq -r '.package.version' manifest.json)
              PACKAGE_TYPE=$(jq -r '.package.type' manifest.json)
              PLATFORM=$(jq -r '.package.platform' manifest.json)
              echo "Version: $VERSION"
              echo "Type: $PACKAGE_TYPE"
              echo "Platform: $PLATFORM"
              echo ""
          fi
          
          # Function to show menu
          show_menu() {
              echo "Select installation option:"
              echo "1) Install Application"
              echo "2) Install Dependencies"
              echo "3) Load Docker Images"
              echo "4) Deploy to Kubernetes"
              echo "5) Full Installation"
              echo "0) Exit"
              echo ""
              read -p "Enter choice: " choice
              return $choice
          }
          
          # Install functions
          install_app() {
              echo "Installing application..."
              if [ -d app ]; then
                  cp -r app /opt/fortinet/ 2>/dev/null || cp -r app ~/fortinet/
                  echo "Application installed!"
              else
                  echo "Application files not found!"
              fi
          }
          
          install_deps() {
              echo "Installing dependencies..."
              if [ -d deps ]; then
                  cd deps
                  if [ -f install-python.sh ]; then
                      ./install-python.sh
                  fi
                  cd ..
                  echo "Dependencies installed!"
              else
                  echo "Dependencies not included in this package"
              fi
          }
          
          load_docker() {
              echo "Loading Docker images..."
              if [ -d docker ] && [ -f docker/load-images.sh ]; then
                  cd docker
                  ./load-images.sh
                  cd ..
              else
                  echo "Docker images not included in this package"
              fi
          }
          
          deploy_k8s() {
              echo "Deploying to Kubernetes..."
              if [ -d k8s ] && [ -f k8s/deploy.sh ]; then
                  cd k8s
                  ./deploy.sh
                  cd ..
              else
                  echo "Kubernetes manifests not included in this package"
              fi
          }
          
          # Main installation loop
          while true; do
              show_menu
              choice=$?
              
              case $choice in
                  1) install_app ;;
                  2) install_deps ;;
                  3) load_docker ;;
                  4) deploy_k8s ;;
                  5) 
                      install_app
                      install_deps
                      load_docker
                      echo "Full installation complete!"
                      ;;
                  0) 
                      echo "Exiting installer..."
                      exit 0
                      ;;
                  *) 
                      echo "Invalid option!"
                      ;;
              esac
              
              echo ""
              echo "Press Enter to continue..."
              read
          done
          EOF
          chmod +x final-package/install.sh
          
          # Create README
          cat > final-package/README.md << EOF
          # Fortinet Offline Package
          
          ## Package Information
          - **Version**: ${{ needs.prepare.outputs.version }}
          - **Package ID**: ${{ needs.prepare.outputs.package_id }}
          - **Type**: ${{ github.event.inputs.package_type }}
          - **Platform**: ${{ github.event.inputs.target_platform }}
          - **Dependencies**: ${{ github.event.inputs.include_dependencies }}
          
          ## Quick Start
          
          1. Extract the package
          2. Run \`./install.sh\` for interactive installation
          3. Or use specific installers in each directory
          
          ## Directory Structure
          - \`app/\` - Application source code
          - \`deps/\` - Dependencies (if included)
          - \`docker/\` - Docker images and compose files
          - \`k8s/\` - Kubernetes manifests
          - \`scripts/\` - Utility scripts
          - \`config/\` - Configuration files
          - \`docs/\` - Documentation
          
          ## Manual Installation
          
          ### Application Only
          \`\`\`bash
          cd app
          python3 src/main.py --web
          \`\`\`
          
          ### With Docker
          \`\`\`bash
          cd docker
          ./load-images.sh
          docker-compose up -d
          \`\`\`
          
          ### With Kubernetes
          \`\`\`bash
          cd k8s
          ./deploy.sh
          \`\`\`
          
          ## Support
          
          For issues, check the documentation in the \`docs/\` directory.
          EOF
      
      - name: Create archive
        run: |
          cd final-package
          
          # Create archive based on compression choice
          ARCHIVE_NAME="${{ env.PACKAGE_PREFIX }}-${{ needs.prepare.outputs.package_id }}-${{ github.event.inputs.package_type }}"
          
          case "${{ github.event.inputs.compression }}" in
            tar.gz)
              tar -czf "../${ARCHIVE_NAME}.tar.gz" .
              FINAL_FILE="${ARCHIVE_NAME}.tar.gz"
              ;;
            tar.xz)
              tar -cJf "../${ARCHIVE_NAME}.tar.xz" .
              FINAL_FILE="${ARCHIVE_NAME}.tar.xz"
              ;;
            zip)
              zip -r "../${ARCHIVE_NAME}.zip" .
              FINAL_FILE="${ARCHIVE_NAME}.zip"
              ;;
          esac
          
          cd ..
          
          # Generate checksums
          sha256sum "${FINAL_FILE}" > "${FINAL_FILE}.sha256"
          md5sum "${FINAL_FILE}" > "${FINAL_FILE}.md5"
          
          # Display package info
          echo "Package created: ${FINAL_FILE}"
          echo "Size: $(du -h ${FINAL_FILE} | cut -f1)"
          echo "SHA256: $(cat ${FINAL_FILE}.sha256)"
          echo "MD5: $(cat ${FINAL_FILE}.md5)"
      
      - name: Upload final package
        uses: actions/upload-artifact@v4
        with:
          name: offline-package-${{ needs.prepare.outputs.package_id }}
          path: |
            ${{ env.PACKAGE_PREFIX }}-*
          retention-days: 30
      
      - name: Create release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: |
            ${{ env.PACKAGE_PREFIX }}-*
          body: |
            ## Offline Package Release
            
            **Version**: ${{ needs.prepare.outputs.version }}
            **Package ID**: ${{ needs.prepare.outputs.package_id }}
            **Type**: ${{ github.event.inputs.package_type }}
            **Platform**: ${{ github.event.inputs.target_platform }}
            
            ### Installation
            1. Download the package for your platform
            2. Extract the archive
            3. Run `./install.sh` for interactive installation
            
            ### Package Contents
            - Application source code
            - Dependencies (if selected)
            - Docker images (if selected)
            - Kubernetes manifests (if selected)
            - Installation scripts
            - Documentation
            
            ### Verification
            Verify package integrity using the provided checksum files:
            - `.sha256` - SHA-256 checksum
            - `.md5` - MD5 checksum
          draft: false
          prerelease: false