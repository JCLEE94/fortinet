name: GitOps Pipeline - FortiGate Nextrade

on:
  push:
    branches: [ master, main, develop ]
  pull_request:
    branches: [ master, main ]

env:
  REGISTRY_URL: registry.jclee.me
  IMAGE_NAME: fortinet
  HELM_CHART_PATH: ./charts/fortinet
  
jobs:
  test:
    name: Test & Quality Check
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov flake8 black isort safety bandit
        
    - name: Code formatting check
      run: |
        black --check src/
        isort --check-only src/
        
    - name: Lint check
      run: |
        flake8 src/ --max-line-length=120 --ignore=E203,W503
        
    - name: Security scan
      run: |
        safety check
        bandit -r src/ -f json -o bandit-report.json || true
        
    - name: Run tests
      run: |
        cd src && python -m pytest ../tests/ -v --cov=. --cov-report=xml
        
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: src/coverage.xml
        fail_ci_if_error: false

  build:
    name: Build & Push Docker Image
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    
    outputs:
      immutable-tag: ${{ steps.meta.outputs.immutable-tag }}
      image-digest: ${{ steps.build.outputs.digest }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Container Registry
      run: |
        echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ${{ env.REGISTRY_URL }} -u ${{ secrets.REGISTRY_USERNAME }} --password-stdin
        
    - name: Extract metadata and create immutable tag
      id: meta
      run: |
        # Create immutable tag: branch-shortcommit
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        SHORT_SHA=${GITHUB_SHA::7}
        IMMUTABLE_TAG="${BRANCH_NAME}-${SHORT_SHA}"
        BUILD_TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
        
        echo "immutable-tag=${IMMUTABLE_TAG}" >> $GITHUB_OUTPUT
        echo "branch=${BRANCH_NAME}" >> $GITHUB_OUTPUT
        echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
        echo "build-timestamp=${BUILD_TIMESTAMP}" >> $GITHUB_OUTPUT
        echo "version=${GITHUB_RUN_NUMBER}" >> $GITHUB_OUTPUT
        
        # Create full image URL
        FULL_IMAGE="${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${IMMUTABLE_TAG}"
        echo "full-image=${FULL_IMAGE}" >> $GITHUB_OUTPUT
        
        echo "Created immutable tag: ${IMMUTABLE_TAG}"
        
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.production
        push: true
        platforms: linux/amd64
        tags: |
          ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.immutable-tag }}
          ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:latest
        labels: |
          org.opencontainers.image.title=FortiGate Nextrade
          org.opencontainers.image.description=Network Monitoring Platform
          org.opencontainers.image.source=https://github.com/${{ github.repository }}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.created=${{ steps.meta.outputs.build-timestamp }}
        build-args: |
          BUILD_DATE=${{ steps.meta.outputs.build-timestamp }}
          BUILD_TIMESTAMP=${{ steps.meta.outputs.build-timestamp }}
          GIT_COMMIT=${{ github.sha }}
          GIT_SHA=${{ steps.meta.outputs.short-sha }}
          GIT_BRANCH=${{ steps.meta.outputs.branch }}
          VERSION=v${{ steps.meta.outputs.version }}
          IMMUTABLE_TAG=${{ steps.meta.outputs.immutable-tag }}
          REGISTRY_URL=${{ env.REGISTRY_URL }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: Verify build metadata
      run: |
        echo "Built image: ${{ steps.meta.outputs.full-image }}"
        echo "Image digest: ${{ steps.build.outputs.digest }}"
        echo "Immutable tag: ${{ steps.meta.outputs.immutable-tag }}"

  helm-package:
    name: Package & Deploy Helm Chart
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'
        
    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: '1.28.0'
        
    - name: Package Helm chart
      run: |
        # Update chart version and app version
        CHART_VERSION="1.2.${{ github.run_number }}"
        APP_VERSION="${{ needs.build.outputs.immutable-tag }}"
        
        # Update Chart.yaml
        sed -i "s/^version:.*/version: ${CHART_VERSION}/" ${{ env.HELM_CHART_PATH }}/Chart.yaml
        sed -i "s/^appVersion:.*/appVersion: \"${APP_VERSION}\"/" ${{ env.HELM_CHART_PATH }}/Chart.yaml
        
        # Package chart
        helm package ${{ env.HELM_CHART_PATH }} --destination ./charts/
        
        echo "Packaged chart with version: ${CHART_VERSION}, appVersion: ${APP_VERSION}"
        
    - name: Upload to ChartMuseum
      run: |
        CHART_FILE=$(ls ./charts/fortinet-*.tgz)
        
        curl -L --data-binary "@${CHART_FILE}" \
          -u "${{ secrets.CHARTMUSEUM_USERNAME }}:${{ secrets.CHARTMUSEUM_PASSWORD }}" \
          "${{ secrets.CHARTMUSEUM_URL }}/api/charts"
          
        echo "Uploaded chart: ${CHART_FILE}"
        
    - name: Deploy with Helm
      run: |
        # Configure kubectl (you'll need to set up kubeconfig secret)
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > /tmp/kubeconfig
        export KUBECONFIG=/tmp/kubeconfig
        
        # Create namespace if it doesn't exist
        kubectl create namespace fortinet --dry-run=client -o yaml | kubectl apply -f -
        
        # Create image pull secret
        kubectl create secret docker-registry harbor-registry \
          --docker-server=${{ env.REGISTRY_URL }} \
          --docker-username=${{ secrets.REGISTRY_USERNAME }} \
          --docker-password=${{ secrets.REGISTRY_PASSWORD }} \
          --namespace=fortinet \
          --dry-run=client -o yaml | kubectl apply -f -
          
        # Deploy with Helm using immutable tag
        helm upgrade --install fortinet ${{ env.HELM_CHART_PATH }} \
          --namespace fortinet \
          --set image.tag="${{ needs.build.outputs.immutable-tag }}" \
          --set image.pullPolicy="IfNotPresent" \
          --timeout=10m \
          --wait
          
        echo "Deployed fortinet with immutable tag: ${{ needs.build.outputs.immutable-tag }}"

  argocd-sync:
    name: Trigger ArgoCD Sync
    needs: [build, helm-package]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    
    steps:
    - name: Trigger ArgoCD sync
      run: |
        # Update ArgoCD application to use new image
        curl -X POST "${{ secrets.ARGOCD_SERVER }}/api/v1/applications/fortinet/sync" \
          -H "Authorization: Bearer ${{ secrets.ARGOCD_TOKEN }}" \
          -H "Content-Type: application/json" \
          -d '{
            "prune": false,
            "dryRun": false,
            "strategy": {
              "hook": {
                "force": true
              }
            }
          }' || echo "ArgoCD sync request sent (may fail if app doesn't exist yet)"
          
    - name: Wait for ArgoCD deployment
      run: |
        echo "Waiting for ArgoCD to sync and deploy..."
        sleep 30
        
        # Check deployment status
        curl -s "${{ secrets.ARGOCD_SERVER }}/api/v1/applications/fortinet" \
          -H "Authorization: Bearer ${{ secrets.ARGOCD_TOKEN }}" | \
          jq -r '.status.sync.status, .status.health.status' || echo "Status check failed"

  verify-deployment:
    name: Verify Deployment
    needs: [build, helm-package, argocd-sync]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    
    steps:
    - name: Verify health endpoint
      run: |
        echo "Waiting for deployment to be ready..."
        sleep 60
        
        # Test NodePort endpoint
        HEALTH_URL="http://${{ secrets.DEPLOYMENT_HOST }}:${{ secrets.DEPLOYMENT_PORT }}/api/health"
        
        for i in {1..10}; do
          echo "Health check attempt $i/10..."
          
          if curl -s --max-time 10 "${HEALTH_URL}" | jq -e '.status == "healthy"'; then
            echo "✅ Health check passed!"
            
            # Verify GitOps metadata
            echo "Verifying GitOps metadata..."
            curl -s "${HEALTH_URL}" | jq '.build_info'
            
            # Check if immutable tag matches
            DEPLOYED_TAG=$(curl -s "${HEALTH_URL}" | jq -r '.build_info.immutable_tag // "unknown"')
            EXPECTED_TAG="${{ needs.build.outputs.immutable-tag }}"
            
            if [ "${DEPLOYED_TAG}" = "${EXPECTED_TAG}" ]; then
              echo "✅ Immutable tag verification passed: ${DEPLOYED_TAG}"
              exit 0
            else
              echo "❌ Tag mismatch - Expected: ${EXPECTED_TAG}, Got: ${DEPLOYED_TAG}"
            fi
          else
            echo "Health check failed, retrying in 30s..."
            sleep 30
          fi
        done
        
        echo "❌ Deployment verification failed"
        exit 1

  notify:
    name: Deployment Notification
    needs: [build, helm-package, argocd-sync, verify-deployment]
    runs-on: ubuntu-latest
    if: always() && github.event_name == 'push' && github.ref == 'refs/heads/master'
    
    steps:
    - name: Deployment notification
      run: |
        if [ "${{ needs.verify-deployment.result }}" = "success" ]; then
          echo "🎉 GitOps Deployment Successful!"
          echo "✅ Image: ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.immutable-tag }}"
          echo "✅ Health: http://${{ secrets.DEPLOYMENT_HOST }}:${{ secrets.DEPLOYMENT_PORT }}/api/health"
          echo "✅ App: http://${{ secrets.DEPLOYMENT_HOST }}:${{ secrets.DEPLOYMENT_PORT }}/"
        else
          echo "❌ GitOps Deployment Failed"
          echo "Check the logs above for details"
          exit 1
        fi