name: Build and Deploy

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

env:
  REGISTRY: ${{ vars.REGISTRY }}
  IMAGE_NAME: ${{ vars.IMAGE_NAME }}

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Private Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}
    
    - name: Build and push
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
        cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
        platforms: linux/amd64,linux/arm64
    
    - name: Auto Deploy to Production
      if: success() && github.ref == 'refs/heads/master'
      run: |
        echo "🚀 Starting auto-deployment process..."
        
        # Create deployment environment file
        cat > .env.deploy << EOF
        REGISTRY=${{ env.REGISTRY }}
        IMAGE_NAME=${{ env.IMAGE_NAME }}
        APP_PORT=${{ vars.APP_PORT }}
        LOG_LEVEL=${{ vars.LOG_LEVEL }}
        TZ=${{ vars.TZ }}
        FORTIGATE_HOST=${{ vars.FORTIGATE_HOST }}
        FORTIGATE_TOKEN=${{ secrets.FORTIGATE_TOKEN }}
        FORTIMANAGER_HOST=${{ vars.FORTIMANAGER_HOST }}
        FORTIMANAGER_USERNAME=${{ vars.FORTIMANAGER_USERNAME }}
        FORTIMANAGER_PASSWORD=${{ secrets.FORTIMANAGER_PASSWORD }}
        REGISTRY_USERNAME=${{ secrets.REGISTRY_USERNAME }}
        REGISTRY_PASSWORD=${{ secrets.REGISTRY_PASSWORD }}
        EOF
        
        # Deploy using single container
        echo "📦 Deploying single container..."
        
        # Stop and remove existing container
        docker stop fortinet-app 2>/dev/null || true
        docker rm fortinet-app 2>/dev/null || true
        
        # Run new container
        docker run -d \
          --name fortinet-app \
          --restart unless-stopped \
          -p ${{ vars.APP_PORT }}:7777 \
          -e APP_MODE=production \
          -e FLASK_ENV=production \
          -e LOG_LEVEL=${{ vars.LOG_LEVEL }} \
          -e TZ="${{ vars.TZ }}" \
          -e FORTIGATE_HOST="${{ vars.FORTIGATE_HOST }}" \
          -e FORTIGATE_TOKEN="${{ secrets.FORTIGATE_TOKEN }}" \
          -e FORTIMANAGER_HOST="${{ vars.FORTIMANAGER_HOST }}" \
          -e FORTIMANAGER_USERNAME="${{ vars.FORTIMANAGER_USERNAME }}" \
          -e FORTIMANAGER_PASSWORD="${{ secrets.FORTIMANAGER_PASSWORD }}" \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        # Wait for container to be ready
        echo "⏳ Waiting for container to be ready..."
        sleep 10
        
        # Verify container is running
        if docker ps --filter "name=fortinet-app" --filter "status=running" | grep -q fortinet-app; then
          echo "✅ Deployment successful!"
          echo "🌐 Service available at: http://localhost:${{ vars.APP_PORT }}"
          echo "📊 Health check: http://localhost:${{ vars.APP_PORT }}/api/health"
          
          # Show container status
          docker ps --filter "name=fortinet-app"
        else
          echo "❌ Deployment failed!"
          echo "Container logs:"
          docker logs fortinet-app --tail=50 2>/dev/null || echo "No logs available"
          exit 1
        fi
        
        # Cleanup
        rm -f .env.deploy
        
        echo "🎉 Auto-deployment completed successfully!"