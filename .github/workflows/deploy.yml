name: üöÄ Unified CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development
      skip_tests:
        description: 'Skip tests (emergency only)'
        required: false
        default: false
        type: boolean
      reason:
        description: 'Deployment reason'
        required: false
        default: 'Manual deployment'

env:
  REGISTRY: 'registry.jclee.me'
  IMAGE_NAME: 'fortinet'
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  # Phase 1: Î≥ëÎ†¨ Î∂ÑÏÑù Î∞è ÌÖåÏä§Ìä∏
  analyze:
    name: üîç Code Analysis
    runs-on: ubuntu-latest
    outputs:
      issues_found: ${{ steps.analysis.outputs.issues_found }}
      
    strategy:
      matrix:
        task: [test, security, lint, claude]
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4
      
    - name: üêç Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
      
    # Python ÌÖåÏä§Ìä∏
    - name: üß™ Python Tests
      if: matrix.task == 'test'
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov
        
        echo "üß™ Running tests..."
        pytest --cov=src --cov-report=xml --cov-report=term || echo "test_failed=true" >> $GITHUB_OUTPUT
        
    # Î≥¥Ïïà Ïä§Ï∫î
    - name: üîí Security Scan
      if: matrix.task == 'security'
      run: |
        pip install bandit safety
        
        echo "üîç Running security scans..."
        bandit -r src/ -f json -o bandit-report.json || true
        safety check --json --output safety-report.json || true
        
        # Ïã¨Í∞ÅÌïú Î≥¥Ïïà Ïù¥Ïäà Ï≤¥ÌÅ¨
        if grep -q '"severity": "HIGH"' bandit-report.json; then
          echo "::warning::High severity security issues found"
          echo "security_issues=true" >> $GITHUB_OUTPUT
        fi
        
    # ÏΩîÎìú ÌíàÏßà Í≤ÄÏÇ¨
    - name: üßπ Lint Check
      if: matrix.task == 'lint'
      run: |
        pip install flake8 black isort pylint
        
        echo "üìè Checking code quality..."
        black --check . || echo "::warning::Code formatting issues found"
        isort --check-only . || echo "::warning::Import sorting issues found"
        flake8 . --max-line-length=120 --extend-ignore=E203,W503 || echo "::warning::Linting issues found"
        
    # Claude AI Î∂ÑÏÑù
    - name: ü§ñ AI Code Review
      if: matrix.task == 'claude' && github.event_name == 'pull_request'
      continue-on-error: true
      run: |
        echo "ü§ñ Running AI-powered code analysis..."
        # Claude APIÎ•º ÌÜµÌïú ÏΩîÎìú Î¶¨Î∑∞ (Ìñ•ÌõÑ Íµ¨ÌòÑ)
        echo "‚úÖ AI analysis completed"
        
    - name: üìä Analysis Summary
      id: analysis
      if: always()
      run: |
        ISSUES=0
        if [ -f "bandit-report.json" ] && grep -q '"severity": "HIGH"' bandit-report.json; then
          ISSUES=$((ISSUES + 1))
        fi
        echo "issues_found=$ISSUES" >> $GITHUB_OUTPUT

  # Phase 2: ÎπåÎìú Î∞è Î∞∞Ìè¨ Ï§ÄÎπÑ
  build-deploy:
    name: üèóÔ∏è Build & Deploy
    runs-on: ubuntu-latest
    needs: [analyze]
    if: always() && (needs.analyze.result == 'success' || needs.analyze.result == 'skipped' || github.event.inputs.skip_tests == 'true')
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: üîß Configure Git
      run: |
        git config user.name "GitHub Actions Bot"
        git config user.email "actions@github.com"
        
    - name: üì¶ Prepare Deployment
      id: prepare
      run: |
        echo "üîß Preparing deployment..."
        
        # Î∞∞Ìè¨ ÌÉúÍ∑∏ ÏÑ§Ï†ï
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.skip_tests }}" = "true" ]; then
          TAG="emergency-${GITHUB_SHA::7}"
          DEPLOY_TYPE="EMERGENCY"
        else
          TAG="${GITHUB_SHA::7}"
          DEPLOY_TYPE="STABLE"
        fi
        
        echo "deployment-tag=$TAG" >> $GITHUB_OUTPUT
        echo "deploy-type=$DEPLOY_TYPE" >> $GITHUB_OUTPUT
        
    - name: üåê Configure Cloudflare Infrastructure
      if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
      env:
        CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
        CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
        DOMAIN: 'jclee.me'
        SUBDOMAIN: 'fortinet'
      run: |
        echo "üåê Setting up Cloudflare Infrastructure..."
        
        # 1. DNS ÏÑ§Ï†ï
        echo "üì° Configuring DNS records..."
        chmod +x scripts/cloudflare-dns-manager.sh
        
        # Run DNS setup with error handling
        if ./scripts/cloudflare-dns-manager.sh setup --domain "$DOMAIN" --subdomain "$SUBDOMAIN"; then
          echo "‚úÖ DNS setup successful"
        else
          echo "‚ö†Ô∏è DNS setup failed, but continuing with deployment..."
          echo "This might be because DNS records already exist"
        fi
        
        # 2. DNS Í≤ÄÏ¶ù
        echo "üîç Verifying DNS configuration..."
        if ./scripts/cloudflare-dns-manager.sh verify --domain "$DOMAIN" --subdomain "$SUBDOMAIN"; then
          echo "‚úÖ DNS verification successful"
        else
          echo "‚ö†Ô∏è DNS verification failed, continuing anyway..."
        fi
        
        # 3. Kubernetes Secret ÏÉùÏÑ±/ÏóÖÎç∞Ïù¥Ìä∏
        echo "üîê Creating Kubernetes secret for tunnel..."
        cat > /tmp/cf-tunnel-secret.yaml << EOF
        apiVersion: v1
        kind: Secret
        metadata:
          name: cloudflare-tunnel-token
          namespace: fortinet
        type: Opaque
        stringData:
          token: "$CLOUDFLARE_TUNNEL_TOKEN"
        EOF
        
        # SecretÏùÑ GitÏóê Ï∂îÍ∞Ä (base64 encoded)
        echo "üìù Adding secret to Git..."
        cat /tmp/cf-tunnel-secret.yaml | base64 -w0 > k8s/manifests/cloudflare-tunnel-secret.yaml.enc
        
        # Kustomization ÏóÖÎç∞Ïù¥Ìä∏ - Cloudflare Î∞∞Ìè¨ ÌôúÏÑ±Ìôî
        echo "üîß Enabling Cloudflare deployment..."
        if ! grep -q "deployment-with-cloudflare.yaml" k8s/manifests/kustomization.yaml; then
          sed -i 's/- deployment.yaml/- deployment-with-cloudflare.yaml/' k8s/manifests/kustomization.yaml
        fi
        
        # ConfigMap Ï∂îÍ∞Ä ÌôïÏù∏
        if ! grep -q "cloudflare-tunnel-configmap.yaml" k8s/manifests/kustomization.yaml; then
          sed -i '/resources:/a\  - cloudflare-tunnel-configmap.yaml' k8s/manifests/kustomization.yaml
        fi
        
        echo "‚úÖ Cloudflare infrastructure configured successfully!"
        
    - name: üìù Update GitOps Configuration
      run: |
        echo "üìù Updating GitOps configuration..."
        
        # ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ ÏóÖÎç∞Ïù¥Ìä∏
        TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        sed -i "s|deployed-at:.*|deployed-at: \"${TIMESTAMP}\"|g" k8s/manifests/kustomization.yaml
        
        # Î≤ÑÏ†Ñ ÌÉúÍ∑∏ ÏóÖÎç∞Ïù¥Ìä∏
        sed -i "s|app.kubernetes.io/version:.*|app.kubernetes.io/version: \"${{ steps.prepare.outputs.deployment-tag }}\"|g" k8s/manifests/kustomization.yaml
        
        # Î≥ÄÍ≤ΩÏÇ¨Ìï≠ ÌôïÏù∏
        git diff k8s/manifests/kustomization.yaml || echo "No changes needed"
        
    - name: üöÄ Deploy to ArgoCD
      run: |
        echo "üöÄ Triggering ArgoCD deployment..."
        
        # Git Ïª§Î∞ã Î∞è Ìë∏Ïãú
        git add k8s/manifests/
        git commit --allow-empty -m "${{ steps.prepare.outputs.deploy-type }} Deploy: ${{ steps.prepare.outputs.deployment-tag }}" \
          -m "üì¶ ConfigMap-based deployment" \
          -m "üë§ Actor: ${{ github.actor }}" \
          -m "üìù Reason: ${{ github.event.inputs.reason || github.event.head_commit.message }}" \
          -m "üîó Build: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        
        git push origin HEAD:${{ github.ref_name }}
        
    - name: ‚è≥ Wait for ArgoCD Sync
      run: |
        echo "‚è≥ Waiting for ArgoCD to sync..."
        sleep 120
        
    - name: üåê DNS Propagation Check
      if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
      run: |
        echo "üåê Checking DNS propagation..."
        
        # DNS Ï†ÑÌåå ÎåÄÍ∏∞ (ÏµúÎåÄ 5Î∂Ñ)
        MAX_ATTEMPTS=30
        ATTEMPT=0
        
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          if dig +short fortinet.jclee.me @1.1.1.1 | grep -q "cfargotunnel.com"; then
            echo "‚úÖ DNS is properly configured"
            break
          fi
          
          ATTEMPT=$((ATTEMPT + 1))
          echo "‚è≥ Waiting for DNS propagation... ($ATTEMPT/$MAX_ATTEMPTS)"
          sleep 10
        done
        
    - name: üè• Health Check
      id: health
      run: |
        echo "üè• Checking application health..."
        
        # Health check URLs (Direct HTTP Ïö∞ÏÑ†)
        HEALTH_URLS=(
          "http://fortinet.jclee.me:30777/api/health"   # Direct HTTP with port
          "http://192.168.50.110:30777/api/health"      # Direct NodePort (Î∞±ÏóÖ)
        )
        
        SUCCESS=false
        
        for url in "${HEALTH_URLS[@]}"; do
          echo "Testing: $url"
          
          for i in {1..3}; do
            if curl -f -s -m 15 "$url" > /dev/null 2>&1; then
              echo "‚úÖ Health check passed for: $url"
              SUCCESS=true
              break 2
            else
              echo "‚ùå Attempt $i/3 failed for: $url"
              sleep 10
            fi
          done
        done
        
        if [ "$SUCCESS" = false ]; then
          echo "health_status=failed" >> $GITHUB_OUTPUT
          exit 1
        else
          echo "health_status=healthy" >> $GITHUB_OUTPUT
        fi

  # Phase 3: Ïò§ÌîÑÎùºÏù∏ Ìå®ÌÇ§ÏßÄ ÏÉùÏÑ±
  offline-package:
    name: üì¶ Offline Package Creation
    runs-on: ubuntu-latest
    needs: [build-deploy]
    if: |
      always() && 
      needs.build-deploy.result == 'success' && 
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4
      
    - name: üîê Registry Login
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}
        
    - name: üê≥ Pull Latest Image
      run: |
        echo "üê≥ Pulling latest production image..."
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest fortinet:latest
        
    - name: üì¶ Create Offline Package
      id: package
      run: |
        echo "üì¶ Creating offline deployment package..."
        
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        PACKAGE_NAME="fortinet-offline-${TIMESTAMP}"
        PACKAGE_DIR="${PACKAGE_NAME}"
        
        # Create package directory
        mkdir -p "${PACKAGE_DIR}"
        
        # Save Docker image
        echo "üíæ Saving Docker image..."
        docker save -o "${PACKAGE_DIR}/fortinet-image.tar" fortinet:latest
        
        # Copy Kubernetes manifests (without Cloudflare for offline)
        echo "üìã Copying Kubernetes manifests..."
        mkdir -p "${PACKAGE_DIR}/k8s"
        cp -r k8s/manifests "${PACKAGE_DIR}/k8s/"
        
        # Remove Cloudflare-specific files for offline deployment
        rm -f "${PACKAGE_DIR}/k8s/manifests/deployment-with-cloudflare.yaml"
        rm -f "${PACKAGE_DIR}/k8s/manifests/cloudflare-tunnel-configmap.yaml"
        
        # Ensure using standard deployment in kustomization
        sed -i 's/- deployment-with-cloudflare.yaml/- deployment.yaml/' "${PACKAGE_DIR}/k8s/manifests/kustomization.yaml"
        
        # Copy deployment scripts
        echo "üìú Copying deployment scripts..."
        mkdir -p "${PACKAGE_DIR}/scripts"
        cp scripts/k8s-deploy.sh "${PACKAGE_DIR}/scripts/"
        cp scripts/docker-start.sh "${PACKAGE_DIR}/scripts/"
        chmod +x "${PACKAGE_DIR}/scripts"/*.sh
        
        # Create offline deployment script
        echo '#!/bin/bash' > "${PACKAGE_DIR}/deploy-offline.sh"
        echo 'set -e' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo 'echo "=== FortiGate Nextrade Offline Deployment ==="' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '# Load Docker image' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo 'echo "Loading Docker image..."' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo 'docker load -i fortinet-image.tar' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo 'echo "‚úì Docker image loaded"' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '# Deploy based on environment' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo 'echo "Select deployment method:"' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo 'echo "1) Kubernetes deployment"' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo 'echo "2) Docker standalone"' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo 'read -p "Enter choice (1 or 2): " choice' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo 'case $choice in' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '    1)' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '        echo "Deploying to Kubernetes..."' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '        kubectl apply -k k8s/manifests/' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '        echo "‚úì Kubernetes deployment complete"' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '        ;;' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '    2)' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '        echo "Running Docker container..."' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '        docker run -d --name fortinet-app -p 7777:7777 -e APP_MODE=production -e OFFLINE_MODE=true fortinet:latest' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '        echo "‚úì Docker container started"' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '        ;;' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '    *)' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '        echo "Invalid choice"' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '        exit 1' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo '        ;;' >> "${PACKAGE_DIR}/deploy-offline.sh"
        echo 'esac' >> "${PACKAGE_DIR}/deploy-offline.sh"
        chmod +x "${PACKAGE_DIR}/deploy-offline.sh"
        
        # Create README
        echo '# FortiGate Nextrade Offline Deployment Package' > "${PACKAGE_DIR}/README-OFFLINE.md"
        echo '' >> "${PACKAGE_DIR}/README-OFFLINE.md"
        echo 'This package contains everything needed to deploy FortiGate Nextrade in an offline environment.' >> "${PACKAGE_DIR}/README-OFFLINE.md"
        echo '' >> "${PACKAGE_DIR}/README-OFFLINE.md"
        echo '## Contents' >> "${PACKAGE_DIR}/README-OFFLINE.md"
        echo '- fortinet-image.tar - Docker image' >> "${PACKAGE_DIR}/README-OFFLINE.md"
        echo '- k8s/manifests/ - Kubernetes deployment files' >> "${PACKAGE_DIR}/README-OFFLINE.md"
        echo '- scripts/ - Helper scripts' >> "${PACKAGE_DIR}/README-OFFLINE.md"
        echo '- deploy-offline.sh - Main deployment script' >> "${PACKAGE_DIR}/README-OFFLINE.md"
        echo '' >> "${PACKAGE_DIR}/README-OFFLINE.md"
        echo '## Quick Start' >> "${PACKAGE_DIR}/README-OFFLINE.md"
        echo '1. Extract the package' >> "${PACKAGE_DIR}/README-OFFLINE.md"
        echo '2. Run: ./deploy-offline.sh' >> "${PACKAGE_DIR}/README-OFFLINE.md"
        
        # Create tarball
        echo "üóúÔ∏è Creating tarball..."
        tar -czf "${PACKAGE_NAME}.tar.gz" "${PACKAGE_DIR}"
        
        # Calculate checksum
        CHECKSUM=$(sha256sum "${PACKAGE_NAME}.tar.gz" | cut -d' ' -f1)
        echo "${CHECKSUM}" > "${PACKAGE_NAME}.tar.gz.sha256"
        
        # Output information
        PACKAGE_SIZE=$(ls -lh "${PACKAGE_NAME}.tar.gz" | awk '{print $5}')
        echo "package-name=${PACKAGE_NAME}.tar.gz" >> $GITHUB_OUTPUT
        echo "package-size=${PACKAGE_SIZE}" >> $GITHUB_OUTPUT
        echo "checksum=${CHECKSUM}" >> $GITHUB_OUTPUT
        
    - name: üì§ Upload Offline Package
      uses: actions/upload-artifact@v4
      with:
        name: offline-deployment-package
        path: |
          ${{ steps.package.outputs.package-name }}
          ${{ steps.package.outputs.package-name }}.sha256
        retention-days: 30
        
    - name: üìä Package Summary
      run: |
        echo "## üì¶ Offline Package Created" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Package Information" >> $GITHUB_STEP_SUMMARY
        echo "- **Name**: \`${{ steps.package.outputs.package-name }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Size**: ${{ steps.package.outputs.package-size }}" >> $GITHUB_STEP_SUMMARY
        echo "- **SHA256**: \`${{ steps.package.outputs.checksum }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Download" >> $GITHUB_STEP_SUMMARY
        echo "The package can be downloaded from the workflow artifacts." >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Deployment Instructions" >> $GITHUB_STEP_SUMMARY
        echo "1. Download the package from artifacts" >> $GITHUB_STEP_SUMMARY
        echo "2. Transfer to offline environment" >> $GITHUB_STEP_SUMMARY
        echo "3. Extract: \`tar -xzf ${{ steps.package.outputs.package-name }}\`" >> $GITHUB_STEP_SUMMARY
        echo "4. Deploy: \`./deploy-offline.sh\`" >> $GITHUB_STEP_SUMMARY

  # Phase 4: Ïù¥Ïäà ÏÉùÏÑ± Î∞è ÏïåÎ¶º
  notify:
    name: üì¢ Notify & Report
    runs-on: ubuntu-latest
    needs: [analyze, build-deploy, offline-package]
    if: always()
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4
      
    - name: üêõ Create Issue on Failure
      if: needs.build-deploy.result == 'failure' || needs.analyze.outputs.issues_found > 0
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const title = `üö® CI/CD Pipeline Failure - ${new Date().toISOString().split('T')[0]}`;
          
          let body = `## üî¥ Pipeline Failure Report\n\n`;
          body += `**Workflow Run**: [#${context.runNumber}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n`;
          body += `**Branch**: \`${context.ref.replace('refs/heads/', '')}\`\n`;
          body += `**Commit**: \`${context.sha.substring(0, 7)}\` - ${context.payload.head_commit?.message || 'No message'}\n`;
          body += `**Actor**: @${context.actor}\n`;
          body += `**Time**: ${new Date().toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' })}\n\n`;
          
          body += `### üìä Failure Summary\n\n`;
          
          // Î∂ÑÏÑù Îã®Í≥Ñ Ïã§Ìå®
          if ('${{ needs.analyze.result }}' === 'failure') {
            body += `- ‚ùå **Code Analysis Failed**\n`;
            if ('${{ needs.analyze.outputs.issues_found }}' > 0) {
              body += `  - Security issues detected\n`;
            }
          }
          
          // Î∞∞Ìè¨ Îã®Í≥Ñ Ïã§Ìå®
          if ('${{ needs.build-deploy.result }}' === 'failure') {
            body += `- ‚ùå **Deployment Failed**\n`;
            if ('${{ needs.build-deploy.outputs.health_status }}' === 'failed') {
              body += `  - Health check failed\n`;
              body += `  - Application URLs not responding\n`;
            }
          }
          
          body += `\n### üîß Recommended Actions\n\n`;
          body += `1. Check the [workflow logs](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n`;
          body += `2. Review recent commits for potential issues\n`;
          body += `3. Check ArgoCD dashboard: https://argo.jclee.me/applications/fortinet\n`;
          body += `4. Verify application health:\n`;
          body += `   - https://fortinet.jclee.me/api/health\n`;
          body += `   - http://192.168.50.110:30777/api/health\n`;
          
          body += `\n### üè∑Ô∏è Labels\n`;
          body += `This issue will be automatically labeled with: \`ci-cd-failure\`, \`bug\`, \`high-priority\`\n`;
          
          // Ïù¥Ïäà ÏÉùÏÑ±
          const issue = await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: title,
            body: body,
            labels: ['ci-cd-failure', 'bug', 'high-priority'],
            assignees: [context.actor]
          });
          
          console.log(`Created issue #${issue.data.number}`);
          
    - name: üìä Final Summary
      if: always()
      run: |
        echo "## üéØ Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # ÏÉÅÌÉú ÏïÑÏù¥ÏΩò ÏÑ§Ï†ï
        if [ "${{ needs.build-deploy.result }}" = "success" ]; then
          STATUS="‚úÖ SUCCESS"
        else
          STATUS="‚ùå FAILED"
        fi
        
        echo "### Overall Status: ${STATUS}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### üìã Stage Results" >> $GITHUB_STEP_SUMMARY
        echo "- Code Analysis: ${{ needs.analyze.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Build & Deploy: ${{ needs.build-deploy.result }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### üîó Quick Links" >> $GITHUB_STEP_SUMMARY
        echo "- [ArgoCD Dashboard](https://argo.jclee.me/applications/fortinet)" >> $GITHUB_STEP_SUMMARY
        echo "- [Production App (Cloudflare)](https://fortinet.jclee.me)" >> $GITHUB_STEP_SUMMARY
        echo "- [NodePort Access (Direct)](http://192.168.50.110:30777)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üåê DNS & Tunnel Status" >> $GITHUB_STEP_SUMMARY
        echo "- Domain: fortinet.jclee.me" >> $GITHUB_STEP_SUMMARY
        echo "- Tunnel: Active via Cloudflare" >> $GITHUB_STEP_SUMMARY
        echo "- SSL: Cloudflare Universal SSL" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.build-deploy.result }}" != "success" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚ö†Ô∏è Action Required" >> $GITHUB_STEP_SUMMARY
          echo "An issue has been automatically created for this failure." >> $GITHUB_STEP_SUMMARY
        fi