name: ArgoCD GitOps Integration

on:
  push:
    branches: [ main, master, develop ]
  workflow_run:
    workflows: ["CI/CD Pipeline - FortiGate Nextrade"]
    types: [completed]

env:
  REGISTRY: registry.jclee.me
  IMAGE_NAME: fortinet
  ARGOCD_SERVER: localhost:30080
  ARGOCD_APP_NAME: fortinet-app

jobs:
  argocd-sync:
    name: 🔄 ArgoCD GitOps Sync
    runs-on: self-hosted
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'push'
    
    steps:
    - name: 📥 Checkout GitOps Repository
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository }}
        token: ${{ secrets.GITHUB_TOKEN }}
        path: gitops
        
    - name: 🔧 Install ArgoCD CLI
      run: |
        echo "🔧 Installing ArgoCD CLI..."
        # Download and install ArgoCD CLI
        curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
        sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
        rm argocd-linux-amd64
        
        # Verify installation
        argocd version --client || echo "ArgoCD CLI installed but server not accessible"
        
    - name: 🔐 ArgoCD Login
      run: |
        echo "🔐 Logging into ArgoCD..."
        # Login to ArgoCD using admin credentials
        argocd login ${{ env.ARGOCD_SERVER }} \
          --username admin \
          --password g0nVB3uL4ccsNiSe \
          --insecure
          
    - name: 📝 Update GitOps Manifests
      run: |
        echo "📝 Updating GitOps manifests..."
        cd gitops
        
        # Create ArgoCD application directory if not exists
        mkdir -p argocd/applications
        mkdir -p argocd/environments/base
        mkdir -p argocd/environments/production
        
        # Update image tag in deployment manifests
        IMAGE_TAG="${{ github.sha }}"
        if [ "${{ github.ref }}" = "refs/heads/main" ] || [ "${{ github.ref }}" = "refs/heads/master" ]; then
          IMAGE_TAG="latest"
        fi
        
        # Create/Update base deployment
        cat > argocd/environments/base/deployment.yaml << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: fortinet
          namespace: fortinet
          labels:
            app: fortinet
            version: ${IMAGE_TAG}
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: fortinet
          template:
            metadata:
              labels:
                app: fortinet
                version: ${IMAGE_TAG}
            spec:
              containers:
              - name: fortinet
                image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}
                ports:
                - containerPort: 7777
                  name: http
                env:
                - name: APP_MODE
                  value: "production"
                - name: WEB_APP_HOST
                  value: "0.0.0.0"
                - name: WEB_APP_PORT
                  value: "7777"
                resources:
                  requests:
                    memory: "512Mi"
                    cpu: "250m"
                  limits:
                    memory: "1Gi"
                    cpu: "500m"
                livenessProbe:
                  httpGet:
                    path: /api/health
                    port: 7777
                  initialDelaySeconds: 30
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /api/health
                    port: 7777
                  initialDelaySeconds: 5
                  periodSeconds: 5
        EOF
        
        # Create service manifest
        cat > argocd/environments/base/service.yaml << EOF
        apiVersion: v1
        kind: Service
        metadata:
          name: fortinet-service
          namespace: fortinet
          labels:
            app: fortinet
        spec:
          type: ClusterIP
          ports:
          - port: 80
            targetPort: 7777
            protocol: TCP
            name: http
          selector:
            app: fortinet
        EOF
        
        # Create namespace manifest
        cat > argocd/environments/base/namespace.yaml << EOF
        apiVersion: v1
        kind: Namespace
        metadata:
          name: fortinet
          labels:
            name: fortinet
        EOF
        
        # Create configmap for app configuration
        cat > argocd/environments/base/configmap.yaml << EOF
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: fortinet-config
          namespace: fortinet
        data:
          app-mode: "production"
          web-app-host: "0.0.0.0"
          web-app-port: "7777"
          offline-mode: "false"
        EOF
        
        # Create PVC for persistent data
        cat > argocd/environments/base/pvc.yaml << EOF
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: fortinet-data
          namespace: fortinet
        spec:
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 5Gi
          storageClassName: default
        EOF
        
        # Create kustomization for base
        cat > argocd/environments/base/kustomization.yaml << EOF
        apiVersion: kustomize.config.k8s.io/v1beta1
        kind: Kustomization
        
        resources:
          - namespace.yaml
          - deployment.yaml
          - service.yaml
          - configmap.yaml
          - pvc.yaml
        
        commonLabels:
          app: fortinet
          managed-by: argocd
        
        images:
          - name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
            newTag: ${IMAGE_TAG}
        EOF
        
        # Create production overlay
        cat > argocd/environments/production/deployment-patch.yaml << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: fortinet
          namespace: fortinet
        spec:
          replicas: 3
          template:
            spec:
              containers:
              - name: fortinet
                resources:
                  requests:
                    memory: "1Gi"
                    cpu: "500m"
                  limits:
                    memory: "2Gi"
                    cpu: "1000m"
        EOF
        
        cat > argocd/environments/production/kustomization.yaml << EOF
        apiVersion: kustomize.config.k8s.io/v1beta1
        kind: Kustomization
        
        resources:
          - ../base
        
        patchesStrategicMerge:
          - deployment-patch.yaml
        
        namespace: fortinet
        
        commonLabels:
          environment: production
        EOF
        
    - name: 🚀 Create/Update ArgoCD Application
      run: |
        echo "🚀 Creating/Updating ArgoCD Application..."
        cd gitops
        
        # Create ArgoCD application manifest
        cat > argocd/applications/fortinet-app.yaml << EOF
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        metadata:
          name: ${{ env.ARGOCD_APP_NAME }}
          namespace: argocd
          labels:
            app: fortinet
          finalizers:
            - resources-finalizer.argocd.argoproj.io
        spec:
          project: default
          source:
            repoURL: https://github.com/${{ github.repository }}.git
            targetRevision: ${{ github.ref_name }}
            path: argocd/environments/production
          destination:
            server: https://kubernetes.default.svc
            namespace: fortinet
          syncPolicy:
            automated:
              prune: true
              selfHeal: true
              allowEmpty: false
            syncOptions:
              - CreateNamespace=true
              - PrunePropagationPolicy=foreground
              - PruneLast=true
            retry:
              limit: 5
              backoff:
                duration: 5s
                factor: 2
                maxDuration: 3m
          revisionHistoryLimit: 10
        EOF
        
        # Apply ArgoCD application
        kubectl apply -f argocd/applications/fortinet-app.yaml || echo "⚠️ ArgoCD application apply failed"
        
        # Alternatively, use ArgoCD CLI
        argocd app create ${{ env.ARGOCD_APP_NAME }} \
          --repo https://github.com/${{ github.repository }}.git \
          --path argocd/environments/production \
          --dest-server https://kubernetes.default.svc \
          --dest-namespace fortinet \
          --revision ${{ github.ref_name }} \
          --sync-policy automated \
          --auto-prune \
          --self-heal \
          --upsert || echo "ArgoCD app already exists, updating..."
        
    - name: 🔄 Sync ArgoCD Application
      run: |
        echo "🔄 Syncing ArgoCD Application..."
        
        # Sync the application
        argocd app sync ${{ env.ARGOCD_APP_NAME }} --prune --force
        
        # Wait for sync to complete
        argocd app wait ${{ env.ARGOCD_APP_NAME }} --timeout 300
        
    - name: ⏱️ Wait for Deployment
      run: |
        echo "⏱️ Waiting for Kubernetes deployment..."
        
        # Wait for deployment to be ready
        kubectl wait --for=condition=available --timeout=300s deployment/fortinet -n fortinet || echo "⚠️ Deployment wait timeout"
        
        # Check pod status
        kubectl get pods -n fortinet -l app=fortinet
        
    - name: 🏥 Health Check
      run: |
        echo "🏥 Performing health check..."
        
        # Get service endpoint
        SERVICE_IP=$(kubectl get svc fortinet-service -n fortinet -o jsonpath='{.spec.clusterIP}')
        
        # Health check through service
        if kubectl run health-check --rm -i --restart=Never --image=curlimages/curl -- \
           curl -f http://${SERVICE_IP}/api/health; then
          echo "✅ Internal health check passed"
        else
          echo "⚠️ Internal health check failed"
        fi
        
        # External health check (if accessible)
        for i in {1..10}; do
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://fortinet.jclee.me/api/health || echo "000")
          if [ "$HTTP_CODE" = "200" ]; then
            echo "✅ External health check passed!"
            break
          else
            echo "⏳ External health check attempt $i failed (HTTP $HTTP_CODE), retrying..."
            sleep 10
          fi
        done
        
    - name: 📊 ArgoCD Application Status
      if: always()
      run: |
        echo "📊 ArgoCD Application Status"
        echo "=========================="
        
        # Get application status
        argocd app get ${{ env.ARGOCD_APP_NAME }} || echo "Failed to get app status"
        
        # List applications
        argocd app list
        
        echo ""
        echo "🔗 ArgoCD UI: http://localhost:30080"
        echo "👤 Username: admin"
        echo "🔑 Password: g0nVB3uL4ccsNiSe"
        echo ""
        echo "✅ GitOps workflow completed!"

    - name: 📝 Commit GitOps Changes
      if: success()
      run: |
        cd gitops
        
        # Configure git
        git config user.name "ArgoCD GitOps Bot"
        git config user.email "gitops@fortinet.jclee.me"
        
        # Add changes
        git add argocd/
        
        # Commit if there are changes
        if ! git diff --cached --quiet; then
          git commit -m "feat: update GitOps manifests for ${{ github.sha }}
          
          - Updated image tag to ${{ github.sha }}
          - Applied via ArgoCD GitOps workflow
          - Deployment environment: production"
          
          # Push changes
          git push origin ${{ github.ref_name }}
          echo "✅ GitOps changes committed and pushed"
        else
          echo "ℹ️ No changes to commit"
        fi