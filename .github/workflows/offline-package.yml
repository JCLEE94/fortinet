name: 📦 Offline Package Builder

on:
  workflow_dispatch:
    inputs:
      package_type:
        description: 'Package Type'
        required: true
        default: 'full'
        type: choice
        options:
        - full           # Complete offline package with all dependencies
        - docker-only    # Docker images only
        - deps-only      # Python dependencies only
        - k8s-only       # Kubernetes manifests only
      include_data:
        description: 'Include sample data'
        required: false
        default: true
        type: boolean
      compression:
        description: 'Compression level'
        required: true
        default: 'medium'
        type: choice
        options:
        - low    # Fast compression
        - medium # Balanced
        - high   # Maximum compression

env:
  PACKAGE_NAME: fortinet-offline
  REGISTRY: registry.jclee.me
  PROJECT_NAME: fortinet
  PYTHON_VERSION: '3.11'

jobs:
  build-offline-package:
    name: 🏗️ Build Offline Package
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for versioning

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y zip tar gzip bzip2 xz-utils
          pip install pip-tools wheel setuptools

      - name: Generate version info
        id: version
        run: |
          VERSION=$(git describe --tags --always --dirty)
          BUILD_DATE=$(date -u +'%Y%m%d')
          BUILD_TIME=$(date -u +'%H%M%S')
          PACKAGE_VERSION="${VERSION}-${BUILD_DATE}-${BUILD_TIME}"
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT
          echo "build_time=$BUILD_TIME" >> $GITHUB_OUTPUT
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          
          # Create version file
          cat > VERSION.txt << EOF
          Version: $VERSION
          Build Date: $BUILD_DATE
          Build Time: $BUILD_TIME
          Package Type: ${{ github.event.inputs.package_type }}
          Git Commit: $(git rev-parse HEAD)
          Git Branch: $(git branch --show-current)
          Builder: GitHub Actions
          EOF

      - name: Create package directory structure
        run: |
          mkdir -p offline-package/{app,docker,k8s,deps,scripts,docs,data}
          
          # Copy application code
          cp -r src offline-package/app/
          cp -r templates offline-package/app/
          cp -r static offline-package/app/
          cp requirements*.txt offline-package/app/
          cp *.py offline-package/app/ 2>/dev/null || true
          cp VERSION.txt offline-package/
          
          # Copy Kubernetes manifests
          cp -r k8s offline-package/
          
          # Copy scripts
          cp -r scripts offline-package/ 2>/dev/null || true
          cp start.sh offline-package/scripts/ 2>/dev/null || true
          
          # Copy documentation
          cp README.md offline-package/docs/
          cp -r docs/* offline-package/docs/ 2>/dev/null || true

      - name: Download Python dependencies
        if: github.event.inputs.package_type == 'full' || github.event.inputs.package_type == 'deps-only'
        run: |
          # Create wheels directory
          mkdir -p offline-package/deps/wheels
          
          # Download all dependencies as wheels
          pip download -r requirements.txt -d offline-package/deps/wheels
          
          # Create requirements file with local paths
          pip freeze > offline-package/deps/requirements-frozen.txt
          
          # Create installation script
          cat > offline-package/deps/install-deps.sh << 'EOF'
          #!/bin/bash
          echo "Installing Python dependencies from offline wheels..."
          pip install --no-index --find-links ./wheels -r requirements-frozen.txt
          echo "Dependencies installed successfully!"
          EOF
          chmod +x offline-package/deps/install-deps.sh

      - name: Build Docker images
        if: github.event.inputs.package_type == 'full' || github.event.inputs.package_type == 'docker-only'
        run: |
          # Build Docker image
          docker build -f Dockerfile.production -t ${{ env.PROJECT_NAME }}:offline .
          
          # Save Docker image as tar
          docker save ${{ env.PROJECT_NAME }}:offline | gzip > offline-package/docker/fortinet-offline.tar.gz
          
          # Create load script
          cat > offline-package/docker/load-images.sh << 'EOF'
          #!/bin/bash
          echo "Loading Docker images..."
          docker load < fortinet-offline.tar.gz
          echo "Docker images loaded successfully!"
          docker images | grep fortinet
          EOF
          chmod +x offline-package/docker/load-images.sh

      - name: Prepare Kubernetes manifests
        if: github.event.inputs.package_type == 'full' || github.event.inputs.package_type == 'k8s-only'
        run: |
          # Update image references for offline deployment
          find offline-package/k8s -name "*.yaml" -type f -exec sed -i 's|registry.jclee.me/fortinet:.*|fortinet:offline|g' {} \;
          
          # Create deployment script
          cat > offline-package/k8s/deploy-offline.sh << 'EOF'
          #!/bin/bash
          echo "Deploying Fortinet to Kubernetes (offline mode)..."
          kubectl apply -k ./overlays/production/
          echo "Deployment initiated!"
          kubectl get pods -n fortinet
          EOF
          chmod +x offline-package/k8s/deploy-offline.sh

      - name: Add sample data
        if: github.event.inputs.include_data == 'true'
        run: |
          # Create sample data
          cat > offline-package/data/sample-config.json << 'EOF'
          {
            "offline_mode": true,
            "mock_mode": true,
            "fortigate_host": "192.168.1.1",
            "fortimanager_host": "192.168.1.2",
            "api_endpoints": {
              "fortigate": "https://192.168.1.1/api/v2",
              "fortimanager": "https://192.168.1.2/jsonrpc"
            }
          }
          EOF
          
          # Add mock data files
          mkdir -p offline-package/data/mock
          cp data/mock/*.json offline-package/data/mock/ 2>/dev/null || true

      - name: Create installation script
        run: |
          cat > offline-package/install.sh << 'EOF'
          #!/bin/bash
          
          echo "========================================="
          echo "Fortinet Offline Package Installer"
          echo "========================================="
          echo ""
          echo "Package Type: ${{ github.event.inputs.package_type }}"
          echo "Version: ${{ steps.version.outputs.package_version }}"
          echo ""
          
          # Function to check prerequisites
          check_prerequisites() {
              echo "Checking prerequisites..."
              
              # Check Python
              if command -v python3 &> /dev/null; then
                  echo "✓ Python3 found: $(python3 --version)"
              else
                  echo "✗ Python3 not found. Please install Python 3.11+"
                  exit 1
              fi
              
              # Check Docker (if needed)
              if [[ "$1" == "full" ]] || [[ "$1" == "docker-only" ]]; then
                  if command -v docker &> /dev/null; then
                      echo "✓ Docker found: $(docker --version)"
                  else
                      echo "✗ Docker not found. Please install Docker"
                      exit 1
                  fi
              fi
              
              # Check kubectl (if needed)
              if [[ "$1" == "full" ]] || [[ "$1" == "k8s-only" ]]; then
                  if command -v kubectl &> /dev/null; then
                      echo "✓ kubectl found: $(kubectl version --client --short)"
                  else
                      echo "⚠ kubectl not found. K8s deployment will not be available"
                  fi
              fi
          }
          
          # Main installation flow
          main() {
              check_prerequisites "${{ github.event.inputs.package_type }}"
              
              echo ""
              echo "Starting installation..."
              echo ""
              
              # Install based on package type
              case "${{ github.event.inputs.package_type }}" in
                  full)
                      echo "Installing full offline package..."
                      cd deps && ./install-deps.sh && cd ..
                      cd docker && ./load-images.sh && cd ..
                      echo "Full package installed!"
                      ;;
                  docker-only)
                      echo "Loading Docker images..."
                      cd docker && ./load-images.sh && cd ..
                      ;;
                  deps-only)
                      echo "Installing Python dependencies..."
                      cd deps && ./install-deps.sh && cd ..
                      ;;
                  k8s-only)
                      echo "Kubernetes manifests ready in k8s/"
                      ;;
              esac
              
              echo ""
              echo "Installation completed successfully!"
              echo ""
              echo "Next steps:"
              echo "1. Configure application settings in data/sample-config.json"
              echo "2. Run the application:"
              echo "   - Local: python3 app/src/main.py --web"
              echo "   - Docker: docker run -p 7777:7777 fortinet:offline"
              echo "   - K8s: cd k8s && ./deploy-offline.sh"
          }
          
          main
          EOF
          chmod +x offline-package/install.sh

      - name: Create README
        run: |
          cat > offline-package/README.md << 'EOF'
          # Fortinet Offline Package
          
          ## Package Information
          - **Version**: ${{ steps.version.outputs.package_version }}
          - **Type**: ${{ github.event.inputs.package_type }}
          - **Build Date**: ${{ steps.version.outputs.build_date }}
          - **Compression**: ${{ github.event.inputs.compression }}
          
          ## Contents
          - `/app` - Application source code
          - `/docker` - Docker images (if included)
          - `/k8s` - Kubernetes manifests
          - `/deps` - Python dependencies (if included)
          - `/scripts` - Utility scripts
          - `/docs` - Documentation
          - `/data` - Sample data and configurations
          
          ## Installation
          
          1. Extract the package:
             ```bash
             tar -xzf fortinet-offline-*.tar.gz
             cd fortinet-offline
             ```
          
          2. Run the installer:
             ```bash
             ./install.sh
             ```
          
          3. Follow the on-screen instructions
          
          ## Manual Installation
          
          ### Python Dependencies
          ```bash
          cd deps
          pip install --no-index --find-links ./wheels -r requirements-frozen.txt
          ```
          
          ### Docker Images
          ```bash
          cd docker
          docker load < fortinet-offline.tar.gz
          ```
          
          ### Kubernetes Deployment
          ```bash
          cd k8s
          kubectl apply -k ./overlays/production/
          ```
          
          ## Running the Application
          
          ### Local Mode
          ```bash
          cd app
          python3 src/main.py --web
          ```
          
          ### Docker Mode
          ```bash
          docker run -d -p 7777:7777 --name fortinet fortinet:offline
          ```
          
          ### Kubernetes Mode
          ```bash
          kubectl port-forward -n fortinet svc/fortinet-service 7777:7777
          ```
          
          ## Support
          
          For issues or questions, please refer to the documentation in `/docs`
          EOF

      - name: Compress package
        run: |
          cd offline-package
          
          # Set compression level
          case "${{ github.event.inputs.compression }}" in
              low)
                  COMPRESS_LEVEL=1
                  ;;
              medium)
                  COMPRESS_LEVEL=6
                  ;;
              high)
                  COMPRESS_LEVEL=9
                  ;;
          esac
          
          # Create compressed archive
          PACKAGE_FILE="${{ env.PACKAGE_NAME }}-${{ steps.version.outputs.package_version }}-${{ github.event.inputs.package_type }}.tar.gz"
          tar -czf "../$PACKAGE_FILE" --level=$COMPRESS_LEVEL .
          
          # Create checksum
          cd ..
          sha256sum "$PACKAGE_FILE" > "$PACKAGE_FILE.sha256"
          
          # Display package info
          echo "Package created: $PACKAGE_FILE"
          echo "Size: $(du -h $PACKAGE_FILE | cut -f1)"
          echo "Checksum: $(cat $PACKAGE_FILE.sha256)"

      - name: Upload package artifact
        uses: actions/upload-artifact@v4
        with:
          name: offline-package-${{ github.event.inputs.package_type }}-${{ steps.version.outputs.build_date }}
          path: |
            fortinet-offline-*.tar.gz
            fortinet-offline-*.tar.gz.sha256
          retention-days: 30

      - name: Create release (if tagged)
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: |
            fortinet-offline-*.tar.gz
            fortinet-offline-*.tar.gz.sha256
          body: |
            ## Offline Package Release
            
            **Version**: ${{ steps.version.outputs.package_version }}
            **Package Type**: ${{ github.event.inputs.package_type }}
            **Build Date**: ${{ steps.version.outputs.build_date }}
            
            ### Installation
            1. Download the package
            2. Extract: `tar -xzf fortinet-offline-*.tar.gz`
            3. Install: `cd fortinet-offline && ./install.sh`
            
            ### Checksums
            Verify the package integrity with the provided SHA256 checksum file.
          draft: false
          prerelease: false